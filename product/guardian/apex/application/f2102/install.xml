<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:ora="http://www.oracle.com/xml/ns/dbchangelog-ext"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.25.xsd"
>
  <preConditions>
    <dbms  type="oracle"/>
    <runningAs  username="ACDC"/>
  </preConditions>

  <changeSet id="apex_f2102" author="mlancast" runOnChange="true">
    <!-- precondition -->
    <preConditions onFail="CONTINUE" onError="HALT">
        <sqlCheck  expectedResult="runtime">select nvl(lower('${guardian_switch}'),'none') v_result from dual</sqlCheck>
    </preConditions>

    <!-- SQL Block for Setting Workspace Name and Parsing Schema -->
    <sql endDelimiter="/">
--
--    DESCRIPTION
--      Shell Script used to install the eFramework APEX applications
--    MODIFIED       DD_MON-YYYY
--       tsthilaire  16-FEB-2014 - Created
--       mipotter    05-NOV-2021 - add workspace name parameter
--       mzimon      18-MAY-2022 - Unified for ADB and PDB.
--       jlyle       27-MAY-2022 - Substitution variable and schema case bug fixes
--       mlancaster  19-JAN-2026 - Use constants, add validate_conversion, remove dead code.
--
-- Check if the application ID already exists for SERT
DECLARE
    c_default_app_id constant number        := 2102;
    c_workspace      constant varchar2(255) := upper('${sert_apex_workspace}');
    c_app_schema     constant varchar2(255) := upper('sert_core');
    c_app_alias      constant varchar2(255) := upper('sert-guardian');

    l_app_id         number := case when validate_conversion('${sert_guardian_app_id}' as number) = 1 then
                                         to_number(coalesce('${sert_guardian_app_id}',0))
                               else 0 end;
    l_workspace_id   number;
    l_app_id_check   number;

    cursor c_app_id (p_alias varchar2, p_workspace_id number) is
       select application_id
         from apex_applications
        where alias = p_alias
          and workspace_id = p_workspace_id;
BEGIN
    -- First step, make sure we are in a clean state.
    apex_application_install.clear_all;

    apex_application_install.set_application_alias(c_app_alias);

    -- Get the Workspace Name ID value
    select workspace_id
      into l_workspace_id
      from apex_workspaces
     where workspace = c_workspace;

    -- Workspace Security
    apex_application_install.set_workspace_id( l_workspace_id );

    -- ----------------------------
    -- Check for application ID migration/change
    -- we will be using l_app_id later. for now this will inform whether the ID is changing
    -- ----------------------------
    open c_app_id (c_app_alias, l_workspace_id);
    fetch c_app_id into l_app_id_check;
    close c_app_id;

    -- User has actually specified a defined APP_ID ( ie, is not null or 0)
    -- AND we have an SERT App in the workspace
    -- AND the app_id are different,
    -- remove the application in prep for install with new ID
    if (l_app_id > 0 and l_app_id_check is not null and l_app_id_check != l_app_id) then
        -- we have an app to remove
        -- workspace is set earlier...
        apex_application_install.set_keep_sessions(false);
        apex_application_install.remove_application(l_app_id_check);
    end if;

    -- Don't force an offset change
    -- we only want to generate an offset if the chosen Application ID
    -- is different from the ID in the import file.
    -- SQLCL imports can fail when APP ID is changed, without generating new offset
    if (coalesce(l_app_id,0) != c_default_app_id ) then
        apex_application_install.generate_offset;
    end if;

    -- Assign ID or auto generate
    if l_app_id >= 1 then
        -- ID given - use the one they provided
        apex_application_install.set_application_id(l_app_id);
    else
        -- No ID given - auto generate or reuse existing if it exists...
        -- l_app_id_check is already fetched
        if l_app_id_check is not null then
            apex_application_install.set_application_id(l_app_id_check);
        else
            apex_application_install.generate_application_id;
        end if;
    end if;

    apex_application_install.set_schema(c_app_schema);

exception when NO_DATA_FOUND then
    -- dbms_output.put_line('ISSUE: The workspace ' || c_workspace || ' does not exist at this time.');
    raise VALUE_ERROR;
END;
/
    </sql>

    <ora:runApexScript ownerName="mlancast" sourceType="FILE" objectType="SCRIPT" objectName="f2102" relativeToChangelogFile="true" >
        <ora:source> install.sql </ora:source>
    </ora:runApexScript>


    <!-- SQL Block for activating the configured Guardian Authentication Scheme -->
    <sql endDelimiter="/">
declare
    --
    --  Activate the configured Guardian Authentication Scheme, default to "Builder Extension Sign-In".
    --
    c_workspace     constant varchar2(255) := upper('${sert_apex_workspace}');
    c_app_alias     constant varchar2(255) := upper('sert-guardian');           -- set during installation
    c_default_authn constant varchar2(255) := 'Builder Extension Sign-In';
    c_authn_scheme  constant varchar2(255) := case
        when '${guardian_authn_scheme}' = '$'||'{guardian_authn_scheme}' then c_default_authn
        else coalesce(trim('${guardian_authn_scheme}'), c_default_authn)
        end;

    l_application_id number;
    l_found          boolean := false;
begin
    -- Make sure we are in a clean state.
    apex_application_install.clear_all;
    apex_util.set_security_group_id(p_security_group_id => apex_util.find_security_group_id(p_workspace => c_workspace));

    -- Find the Guardian app id, which may have been auto-allocated
    select application_id
      into l_application_id
      from apex_applications
     where workspace = c_workspace
       and alias = c_app_alias;

    -- Find the desired authn scheme within the supplied schemes
    for c in (
        select authentication_scheme_name, is_current_authentication
          from apex_application_auth
         where application_id = l_application_id
           and upper(authentication_scheme_name) = upper(c_authn_scheme) )
    loop
        l_found := true;

        -- Activate authentication scheme when not current
        if c.is_current_authentication = 'N' then
            dbms_output.put_line('Activate authentication scheme: '||c.authentication_scheme_name);

            apex_application_admin.set_authentication_scheme(
                p_application_id => l_application_id,
                p_name           => c.authentication_scheme_name );
        end if;
    end loop;

    if not l_found then
        raise_application_error(-20002, 'Failed to activate Authentication Scheme "'||c_authn_scheme||'". This is not a supplied SERT Guardian scheme.');
    end if;
exception
    when no_data_found then
        raise_application_error(-20001, 'SERT Guardian application not found');
end;
/
    </sql>

    <rollback></rollback>
  </changeSet>
</databaseChangeLog>