[
  {
    "ruleName": "Allow Duplicate Submissions",
    "ruleKey": "ALLOW_DUPLICATE_SUBMISSIONS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "aeadm/managing-workspace-and-change-requests.html#GUID-782488EB-8DC0-4D04-974E-800E78369BC5",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "ALLOW_DUPLICATE_SUBMISSIONS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "The **Allow Duplicate Page Submissions** attribute determines whether or not a page can be submitted more than once. \n\nFor example, if this option is enabled, a user can click Submit multiple times, and potentially insert multiple records into the database. Users who use the back button and then try to resubmit a transaction would also be allowed to do so when this attribute is enabled. This would also be the case for a user who accidentally double-clicks a button.\n\nThe recommended setting for this option should be considered on a page-by-page basis, as it will vary based on the function of the page. For pages that insert data into the database or call a procedure, it should be set to `No`. For pages that allow users to filter data, it should be set to `Yes`.\n\nIf this attribute is set to `No`, you can also provide a URL where users will be redirected to, in the case of a duplicate page submission.",
    "fix": "To modify the **Allow Duplicate Page Submissions** attribute:\n\n1.  Edit the page that you want to associate an authorization scheme with.\n2.  Edit the page attributes for the page in question by clicking on it's name in the _Page Rendering_ tree.\n3.  In the Advanced section, set the **Enable duplicate page submissions** attribute to the appropriate value, based on the type of page. For example, it should be set to **No** for DML forms and **Yes** for most other types of pages.\n4.  If setting it to **No**, then optionally supply a URL to redirect users to in the case of a duplicate page submission.\n5.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Low",
    "ruleSeverityKey": "LOW",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Authorization Scheme",
    "ruleKey": "APPLICATION_AUTHORIZATION_SCHEME",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-9DFB08E7-0CA4-4C00-B05F-A0678FAAD326",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "Like most components in APEX, an Application can have an **Authorization Scheme**. By associating the **Authorization Scheme** with the application, only those users who are members of the corresponding **Authorization Scheme** will be able to access the application.\n\nThis technique is critical when using a central Authentication Scheme, such as LDAP. Without an application-level Authorization Scheme, then any user in the LDAP directory will be able to access the application. Thus, it's a best practice to create a group - either in LDAP or via database tables - and add authorized users to that group. The application Authorization Scheme can then check to see if a user is a member of the associated group or not, thus either allowing them or preventing them from using the application.",
    "fix": "  To associate an **Authorization Scheme** with an application:\n\n1.  Edit your application's **Shared Components**.\n2.  In the _Security_ region, click on **Security Attributes**.\n3.  In the _Authorization_ region, set the value of _Authorization Scheme_ to the corresponding **Authorization Scheme**.\n4.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Computation SQLi",
    "ruleKey": "APPLICATION_COMPUTATION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "APP_COMPUTATION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_COMPUTATIONS",
    "columnToEvaluate": "COMPUTATION",
    "componentId": "APPLICATION_COMPUTATION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "COMPUTATION_TYPE:COMPUTATION_ITEM",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Application Computation** definition in question, and edit its **Computation** code in the **Computation** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Items Escaped",
    "ruleKey": "APPLICATION_ITEMS_ESCAPED",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APP_ITEM",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_ITEMS",
    "columnToEvaluate": "ESCAPE_ON_HTTP_OUTPUT",
    "componentId": "APPLICATION_ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "ITEM_NAME",
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Application Items at Risk** are Application Items that have their **Escape Special Characters** attribute set to **No**. \n\nWhen set to **Yes**, any HTML rendered on the page will be properly escaped. When set to **No**, any HTML will be rendered as-is, introducing the risk of malicious code getting executed. \n\nThus, it is recommended to set this **Enable Special Characters** to **Yes**.",
    "fix": "To change the **Escape Special Characters** attribute for an **Application Item**:\n\n1.  Edit your application's **Shared Components**.\n2.  In the Application Logic region, click **Application Items**.\n3.  Click the application item you wish to modify.\n4.  In the Security region, set the **Escape Special Characters** attribute to  **Yes**\n5.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Items Session State",
    "ruleKey": "APPLICATION_ITEMS_SESSION_STATE",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-D3ECB171-681E-4452-BB33-5E74EC0EE13E",
    "builderUrlKey": "APP_ITEM",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_ITEMS",
    "columnToEvaluate": "SESSION_STATE_PROTECTION",
    "componentId": "APPLICATION_ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "ITEM_NAME",
    "operand": "DOES_NOT_EQUAL",
    "valChar": "N",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Application Items at Risk** are Application Items that have their Session State Protection attribute set to **Unrestricted**. \n\nThese application items can be altered by a malicious user via the URL of a page that does not have session state protection enabled, thus potentially changing application functionality.\n\nThere are two different settings:\n\n*   **Unrestricted**  \n    Item can be set via the URL or within APEX  \n*   **Restricted - May not be set from browser**  \n    Item can not be set via the URL under any circumstances - even if Session State Protection is disabled at the application level.",
    "fix": "To change the **Session State Protection** attribute for an **Application Item**:\n\n1.  Edit your application's **Shared Components**.\n2.  In the Application Logic region, click **Application Items**.\n3.  Click the application item you wish to modify.\n4.  In the Security region, set the Session State Protection attribute to any value other than **Unrestricted**.\n5.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Process SQLi",
    "ruleKey": "APPLICATION_PROCESS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "APP_PROCESS",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PROCESSES",
    "columnToEvaluate": "PROCESS",
    "componentId": "APPLICATION_PROCESS_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "PROCESS_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and process is not null\nand process_type_code = 'PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Application Process** definition in question, and edit its **Code** in the **Source** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Rejoin Sessions",
    "ruleKey": "APPLICATION_REJOIN_SESSIONS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "REJOIN_EXISTING_SESSIONS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Disabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Rejoin Sessions** attribute will allow users to rejoin a previously established session without providing a Session ID. APEX will only use the existing cookie to determine whether or not to consider the current session as valid.\n\nEnabling this option does present a security risk, as it would be easier for a hacker to take over an existing APEX session. Thus, this option should be set to Disabled.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session Management** area, locate **Rejoin Sessions** attribute and change its value to Disabled.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Authorization Scheme SQLi",
    "ruleKey": "AUTHORIZATION_SCHEME_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "AUTHORIZATION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_AUTHORIZATION",
    "columnToEvaluate": "ATTRIBUTE_01",
    "componentId": "AUTHORIZATION_SCHEME_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "AUTHORIZATION_SCHEME_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and scheme_type_code in \n  (\n   'NATIVE_EXISTS'\n  ,'NATIVE_FUNCTION_BODY'\n  ,'NATIVE_NOT_EXISTS'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Authorization Scheme** definition in question, and edit its **SQL Query** code in the **Authorization Scheme** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Avatar SQLi",
    "ruleKey": "AVATAR_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$AVATAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Avatar Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Avatar WHERE Clause SQLi",
    "ruleKey": "AVATAR_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$AVATAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Avatar Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Badge SQLi",
    "ruleKey": "BADGE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$BADGE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Badge Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Badge WHERE Clause SQLi",
    "ruleKey": "BADGE_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$BADGE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Badge Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Branch SQLi",
    "ruleKey": "BRANCH_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "BRANCH",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_BRANCHES",
    "columnToEvaluate": "BRANCH_ACTION",
    "componentId": "BRANCH_ID",
    "componentName": "BRANCH_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and (branch_language = 'PLSQL' or branch_type = 'Branch to PL/SQL Procedure')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Branch** in the Page Rendering tree **Branches** List, and edit its **PL/SQL Function Body** in the **Behavior** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Breadcrumb AuthZ Inconsistency",
    "ruleKey": "BREADCRUMB_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "BREADCRUMB",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with b as\n(\nselect\n   be.application_id\n  ,b.breadcrumb_name\n  ,be.entry_label\n  ,be.url\n  ,REGEXP_SUBSTR(be.url, '[^:]+', 1, 2) as target_page_id\n  ,be.authorization_scheme\n  ,be.authorization_scheme_id\n  ,b.breadcrumb_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(be.url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(be.url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(be.url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(be.url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n  apex_application_bc_entries be\n  ,apex_application_breadcrumbs b\nwhere\n  b.breadcrumb_id = be.breadcrumb_id\n  and be.url is not null\n  and be.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,b.application_id as application_id\n  ,null as page_id \n  ,breadcrumb_id as component_id \n  ,b.entry_label as component_name\n  ,null as column_name \n  ,null as item_name\n  ,b.breadcrumb_name as shared_comp_name\n  ,'Entry Label: ' || nvl(b.authorization_scheme,'None') || ' / Page: ' || nvl(b.target_authorization_scheme,'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(b.target_authorization_scheme_id,0) = nvl(b.authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n    end as result\nfrom b\nwhere 1=1\n  and b.application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **Breadcrumbs** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Browser Cache",
    "ruleKey": "BROWSER_CACHE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with a as (select browser_cache from apex_applications where application_id = #APP_ID#)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id\n  ,p.application_id as application_id\n  ,p.page_id page_id\n  ,null as component_id\n  ,null as component_name\n  ,null as column_name\n  ,null as item_name\n  ,null as shared_comp_name\n  ,p.browser_cache || ' (page) / ' || a.browser_cache \n     || ' (app)' as current_value\n  ,'Disabled' as valid_values\n  , case when \n      (case when p.browser_cache = 'Application Default' then a.browser_cache else p.browser_cache end) = 'Disabled' then '{ \"result\":\"PASS\"}' else '{ \"result\":\"FAIL\"}' end as result\nfrom\n  apex_application_pages p\n  ,a\nwhere\n  page_id > 0",
    "info": "**Browser Cache** dictates how the user's browser will store a rendered APEX Page in the browser's cache. Normally, browsers save the contents of an application's pages, however if the cache is disabled, the browser will not save the information and will be forced to reload the information from the server.\n\nFrom a security standpoint, Browser Cache should be disabled so that no sensitive information will not be kept at the browser level. Setting this to **Disabled** will also help prevent subtle back button issues.\n\nNOTE: When Browser Cache is set to **DIsabled**, APEX will include the HTTP Header directive cache-control: no-store indicating the browser should not store page content in either memory or disk. This feature will only work with browsers which support the cache-control directive",
    "fix": "To alter the value of **Browser Cache** for a specific page:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, alter the value for the **Browser Cache** select list.\n3.  Click **Save**.Browser Cache has three possible settings:\n    1.  **Application Default** - This will take its value from the current application's Browser Cache attribute.\n    2.  **Enabled** - Allows the browser to cache information from the page\n    3.  **Disabled** - Prohibits the browser from caching information for the specific page.\n\nThe page level `Browser Cache` setting, other than Application Default, will override what is defined at the Application level.\n\n**NOTE**: When **Browser Cache** is set to \"Disabled\", APEX will include the HTTP Header directive  **cache-control: no-store** indicating the browser should not store page content in either memory or disk. This feature will only work with browsers which support the _**cache-control**_ directive.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Build Status",
    "ruleKey": "BUILD_STATUS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-5D88B80F-1A82-474F-A6BC-C7787CC5703F",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "BUILD_STATUS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Run Only",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Button AuthZ Inconsistency",
    "ruleKey": "BUTTON_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/providing-security-through-authorization.html#GUID-8FBF5F46-0541-4859-8470-D10E333DD271",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with b as\n(\nselect\n   application_id\n  ,page_id\n  ,button_name\n  ,region_id\n  ,button_id\n  ,redirect_url\n  ,REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2) as target_page_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\n  ,authorization_scheme\n  ,authorization_scheme_id\nfrom\n  apex_application_page_buttons\nwhere\n  redirect_url is not null\n  and application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,b.application_id as application_id\n  ,b.page_id page_id \n  ,b.button_id as component_id \n  ,b.button_name as component_name\n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'Button: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n    ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n    end as result\nfrom b\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "The execution of a **Page Process**  can be linked to the click of a specific _button_ on the same page. When the **Authorization Scheme** of the Process and the Button do not match it might be possible for the user to have access to the Button and not the Process or vice versa.\n\nAPEX-SERT flags Page Processes where the execution is tied to a Button, but where the Button's Authorization scheme doesn't match the Authorization Scheme for the Process.",
    "fix": "Check the **Authorization Schemes** on both the driving **Button** and the **Page Process** for compatibility. Although they are not required to be the same, developers need to make sure that the Authorization Schemes are compatible and will provide the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cache",
    "ruleKey": "CACHE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-8DEEFEE2-0BB6-4882-BC84-8549A6497248",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "BROWSER_CACHE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Disabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Browser Cache** dictates how the user's browser will store a rendered APEX Page in the browser's cache. Normally, browsers save the contents of an application's pages, however if the cache is disabled, the browser will not save the information and will be forced to reload the information from the server.\n\nFrom a security standpoint, **Browser Cache** should be disabled so that no sensitive information will not be kept at the browser level. Setting this to **Disabled** will also help prevent subtle back button issues.\n\nNOTE: When Browser Cache is set to **Disabled**, APEX will include the HTTP Header directive cache-control: no-store indicating the browser should not store page content in either memory or disk. This feature will only work with browsers which support the cache-control directive",
    "fix": "Navigate to your Application Definition, and select **Security** tab.\n\nIn **Browser Security** area, locate **Cache** attribute and change its value to Disabled.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Calendar SQLi",
    "ruleKey": "CALENDAR_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_CSS_CALENDAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Calendar Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Calendar WHERE Clause SQLi",
    "ruleKey": "CALENDAR_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_CSS_CALENDAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Calendar Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cards SQLi",
    "ruleKey": "CARDS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_CARDS'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Cards Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cards WHERE Clause SQLi",
    "ruleKey": "CARDS_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_CARDS'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Cards Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Card Action AuthZ Inconsistency",
    "ruleKey": "CARD_ACTION_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\r\n(\r\nselect\r\n ic.application_id\r\n ,ic.page_id\r\n ,REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) as target_page_id\r\n ,ic.region_name\r\n ,ic.region_id\r\n ,ic.action_id as component_id\r\n ,nvl(label, action_type) column_alias \r\n ,coalesce(ic.authorization_scheme, \r\n   r.authorization_scheme, \r\n   pg.authorization_scheme) derived_authorization_scheme\r\n ,coalesce(ic.authorization_scheme_id, \r\n   r.authorization_scheme_id, \r\n   pg.authorization_scheme_id) derived_authorization_scheme_id\r\n  ,(select authorization_scheme\r\n    from apex_application_pages \r\n    where to_char(page_id) = REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) \r\n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \r\n    and application_id = #APP_ID#\r\n   ) target_authorization_scheme\r\n  ,(select authorization_scheme_id\r\n    from apex_application_pages \r\n     where to_char(page_id) = REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) \r\n     and REGEXP_LIKE(REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \r\n     and application_id = #APP_ID#\r\n   ) target_authorization_scheme_id\r\nfrom\r\n   apex_appl_page_card_actions ic\r\n  ,apex_application_page_regions r\r\n  ,apex_application_pages pg\r\nwhere  1=1\r\n  and ic.region_id = r.region_id \r\n  and ic.link_target is not null\r\n  and pg.page_id = ic.page_id\r\n  and pg.application_id = #APP_ID#\r\n  and ic.application_id = #APP_ID#\r\n)\r\nselect #EVAL_ID# as eval_id\r\n  ,#RULE_ID# as rule_id \r\n  ,c.application_id as application_id\r\n  ,c.page_id as page_id \r\n  ,c.component_id component_id \r\n  ,c.column_alias as component_name\r\n  ,null as column_name \r\n  ,null as item_name\r\n  ,null as shared_comp_name\r\n  ,'Action: ' || coalesce(c.derived_authorization_scheme,'None') || ' / Page: ' || nvl(c.target_authorization_scheme,'None') as current_value\r\n  ,'AuthZ Schemes Match' as valid_values\r\n,case \r\n  when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\r\n  when nvl(target_authorization_scheme_id,'0') = coalesce(c.derived_authorization_scheme_id,'0') then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' \r\n  else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' end as result\r\nfrom c",
    "info": "The execution of **Page Processes** can be linked to the click of a specific Button on the same page. When the **Authorization Schemes** of the Process and the Button do not match it might be possible for the user to have access to the Button and not the Process or vice versa.\r\n\r\nAPEX-SERT flags Page Processes where the execution is tied to a Button, but where the Button's Authorization scheme doesn't match the Authorization Scheme for the Process.",
    "fix": "Check the **Authorization Schemes** on both the **Card Action** and the **linked Page**  for compatibility. Although they are not required to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.\r\n\r\nWhen a Card action uses a column substitution for the Action, it cannot be confirmed by APEX-SERT and will require an exception",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart Series SQLi",
    "ruleKey": "CHART_SERIES_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "JET_CHART_SERIES",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_CHART_S",
    "columnToEvaluate": "DATA_SOURCE",
    "componentId": "SERIES_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and data_source is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region Series** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart Series WHERE Clause SQLi",
    "ruleKey": "CHART_SERIES_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_CHART_S",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region Series** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart SQLi",
    "ruleKey": "CHART_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_JET_CHART'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart WHERE Clause SQLi",
    "ruleKey": "CHART_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_JET_CHART'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report Column AuthZ Inconsistency",
    "ruleKey": "CLASSIC_REPORT_COLUMN_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2) as target_page_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\n  ,ic.region_name\n  ,ic.region_id\n  ,ic.column_alias\n  ,ic.authorization_scheme\n  ,ic.authorization_scheme_id\nfrom\n   apex_application_page_rpt_cols ic\n  ,apex_application_page_regions r\nwhere 1=1\n  and ic.region_id = r.region_id \n  and ic.column_link_url is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,c.column_alias as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'Report Column: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report Column Escaped",
    "ruleKey": "CLASSIC_REPORT_COLUMN_ESCAPED",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_RPT_COLS",
    "columnToEvaluate": "DISPLAY_AS_CODE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": "COLUMN_ALIAS",
    "itemName": null,
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "WITHOUT_MODIFICATION",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Classic Report** columns can render HTML as part of their item. In this case, it is important to ensure that the HTML rendered is properly escaped, so that in the case the HTML contains malicious code, it is rendered harmless.\n\n**Classic Report** columns contain a property called **Escape Special Characters**. When set to **Yes**, any HTML rendered on the page will be properly escaped. When set to **No**, any HTML will be rendered as-is, introducing the risk of malicious code getting executed. Thus, it is recommended to set this **Enable Special Characters** to **Yes**.",
    "fix": "To change the **Escape Special Characters** attribute for a **Classic Report** column:\n\n1.  Edit the corresponding page of your application that contains the report in question.\n2.  Expand the Report in the Rendering panel, click on the Tree View toggle next to the affected report.\n3.  Select the column in question.\n4.  In the Column Attribute panel/region, locate the **Security section**, and toggle the switch **Escape Special Characters** attribute to **Yes**.\n5.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report SQLi",
    "ruleKey": "CLASSIC_REPORT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code in ('SQL_QUERY','FUNCTION_RETURNING_SQL_QUERY')\nand source_type_plugin_name = 'NATIVE_SQL_REPORT'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Classic Report Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report WHERE Clause SQLi",
    "ruleKey": "CLASSIC_REPORT_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'SQL_QUERY'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Classic Report Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cleanup PL/SQL Code",
    "ruleKey": "CLEANUP_PLSQL_CODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-F2324900-0AD3-4C0A-8B86-AE4B9C25F991",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "DB_SESSION_CLEANUP_CODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Cleanup PL/SQL Code** is typically used to set the security context of an application. The PL/SQL placed here will execute after everything else on each and every page within your application.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Database Session** area, examine **Cleanup PL/SQL Code** attribute for reported SQL Injections issues. In particular, check usage of DBMS\\_SQL, EXECUTE\\_IMMEDIATE and incorrect item substitution syntax.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Column Toggle SQLi",
    "ruleKey": "COLUMN_TOGGLE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_JQM_COLUMN_TOGGLE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Column Toggle Report Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Column Toggle WHERE Clause SQLi",
    "ruleKey": "COLUMN_TOGGLE_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_JQM_COLUMN_TOGGLE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Column Toggle Report Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Comments SQLi",
    "ruleKey": "COMMENTS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$COMMENTS'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Comments WHERE Clause SQLi",
    "ruleKey": "COMMENTS_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$COMMENTS'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Compatibility Mode",
    "ruleKey": "COMPATIBILITY_MODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A06-2021",
    "riskName": "Vulnerable and Outdated Components",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/upgrading-apex-applications.html#GUID-3415C581-1146-4D64-8044-DE5BD67F186C",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "COMPATIBILITY_MODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "21.2",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Compatibility Mode** attribute controls the backward compatibility of the APEX runtime engine when executing an application. Certain runtime behaviors change from release to release. To not break or change the behavior of existing applications, this attribute is automatically set during upgrade if necessary.",
    "fix": "Navigate to your Application Definition, and select **Definition** tab.  \nIn **Properties** area, locate **Compatibility Mode** attribute and change its value to the desired setting.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Content Row SQLi",
    "ruleKey": "CONTENT_ROW_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$CONTENT_ROW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Content Row WHERE Clause SQLi",
    "ruleKey": "CONTENT_ROW_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$CONTENT_ROW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Debug Mode",
    "ruleKey": "DEBUG_MODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-583B8D2A-D236-4A35-A510-F87BF3C694FA",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "DEBUGGING",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Not Allowed",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Debugging** attribute determines whether or not your application can be run in Debug mode. If enabled, then anyone with knowledge of how APEX works - including end users - can run your application with Debug enabled. This will produce a thorough report of your application logic, code and attributes. Although in APEX 4 and above, debug information is no longer emitted to the page, running an application with Debug enables can hinder performance and potentially show components who's visibility is linked to the Debug setting.\n\nIt is critical that this value be disabled for production applications, as the information provided by debug mode could potentially be used by a hacker to compromise your application.\n\nThis setting should always be set to No, since in APEX 4.2 and above, if you are logged in as a developer and are also running an application, **Debug Mode** will be automatically enabled.",
    "fix": "Navigate to your **Application** Definition, and select **Definition** tab.  \nIn Properties area, locate **Debugging** attribute and set its value to **No**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Dynamic Action SQLi",
    "ruleKey": "DYNAMIC_ACTION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_DA_ACTS",
    "columnToEvaluate": "ATTRIBUTE_01",
    "componentId": "DYNAMIC_ACTION_ID",
    "componentName": "DYNAMIC_ACTION_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and action_code = 'NATIVE_EXECUTE_PLSQL_CODE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Dynamic Action** in the Page Rendering tree, and edit its **PL/SQL Code** in the **Settings** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Dynamic Content Contains Binds",
    "ruleKey": "DYNAMIC_CONTENT_CONTAINS_BINDS",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/cross-site-scripting-protection.html#GUID-3E24746E-378C-478E-85F6-55DD8EC4A367",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "select\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id\n  ,r.application_id as application_id\n  ,r.page_id page_id\n  ,r.region_id as component_id\n  ,null as component_name\n  ,null as column_name\n  ,null as item_name\n  ,null as shared_comp_name\n  ,r.region_source as current_value\n  ,'Returning bind variables should be escaped' as valid_values\n  ,case\n    when REGEXP_COUNT(replace(region_source, ':=', null), ':\\S*\\s', 1, 'i') > 0\n    then\n      '{ \"result\":\"FAIL\"}' else '{ \"result\":\"PASS\"}'\n    end as result\nfrom\n  apex_application_page_regions r\nwhere\n  page_id > 0\n  and source_type_code = 'NATIVE_DYNAMIC_CONTENT'",
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Dynamic Content SQLi",
    "ruleKey": "DYNAMIC_CONTENT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_DYNAMIC_CONTENT'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Embed in Frames",
    "ruleKey": "EMBED_IN_FRAMES",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-8DEEFEE2-0BB6-4882-BC84-8549A6497248",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "BROWSER_FRAME",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Deny:Allow from same origin",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Embed in Frames** dictates whether a browser is allowed to display your application pages within an HTML frame, and if so under what circumstances.\n\nApplications that allow frame embedding are potentially at risk of \"clickjacking\" atacks. This is where an attacker uses multiple page layers to intercept clicks that were meant for buttons or links in the application, instead routing them to another page.\n\nOptions are:\n\n*   **Deny** - The page is not allowed to be rendered within a frame, regardless of the site attempting to do so.\n*   **Allow** - The page can be displayed in any frame, regardless of origin.\n*   **Allow from same origin** - The page can be displayed within a frame, but only if the frame is from the same origin as the page.\n\nNOTE: This feature requires modern browsers that support the HTTP header response variable _X-Frame-Options_.",
    "fix": "Navigate to your **Application** Definition, and select **Security** tab.  \nIn **Browser Security** area, locate **Embed in Frames** attribute and set its value to either **Deny** or **Allow from same origin**.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Error Handling Function",
    "ruleKey": "ERROR_HANDLING_FUNCTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-B744BE26-69B6-4084-A217-114CF05A5A4B",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "ERROR_HANDLING_FUNCTION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The Error Handling Function is a function that will be called when an error is raised from an APEX application. This function can be set to handle specific errors, suppress sensitive information from error messages, and even send notifications when errors occur. This application can be set at the application and page lever, where a page-level setting will override an application-level one.\n\nWhile APEX will work just fine without one, it is strongly recommended that a custom function be deployed and deployed with all applications. The Sample Database Application contains a sample error handling function that can be expanded upon.\n\nThe ErrorHandling Functions must adhere to the following signature:\n\n`function [function name]`   \n `(`  \n  `p_error in apex_error.t_error`  \n `)`  \n`return apex_error.t_error_result;`\n\nSee the Oracle APEX API Reference for more details on how to create an Error Handling Function.",
    "fix": "Navigate to your Application Definition, and select **Definition** tab.  \nIn **Error Handling** area, locate **Error Handling Function** attribute and set its value to not NULL, for example to your PL/SQL error function name.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Facet SQLi",
    "ruleKey": "FACET_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_PAGE_FILTERS",
    "columnToEvaluate": "LOV_DEFINITION",
    "componentId": "REGION_ID",
    "componentName": "ITEM_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and suggestions_type_code = 'DYNAMIC'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Form Autocomplete",
    "ruleKey": "FORM_AUTOCOMPLETE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/identifying-at-risk-passwords.html#GUID-9B68C8BE-83FD-4057-B098-11ADB6B1411B",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "FORM_AUTOCOMPLETE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Off",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "By default, all APEX pages have their **Form Auto Complete** attribute set to enabled. This makes using applications a lot more efficient, as most browsers will remember previous data entered and automatically present those values to users. However, if the data entered is of a sensitive nature - such as credit card, SSN or account numbers - that data will be stored on the client's local browser.\n\nWhile the data stored locallymay be encrypted, it is not password-protected. For example: you enter a credit card number and submit the form. The next time you run that page, the browser will automatically remember which values you previously used. Thus, you will be able to see a list of all previous credit card numbers entered.\n\n**Form Auto Complete** should only be enabled on pages where there is no concern about the data being entered there. For all other pages, **Form Auto Complete** should be disabled.",
    "fix": "To disable **Form Auto Complete**:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region set the value of Form Auto Complete to **Off**.\n3.  Click **Save.**",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Hidden Item Value Protected",
    "ruleKey": "HIDDEN_ITEM_VALUE_PROTECTED",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/about-item-types.html#GUID-8CAA1BA5-DCA8-4DF0-A841-3DC40E67CA9C",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ATTRIBUTE_01",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Y",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and display_as_code = 'NATIVE_HIDDEN'",
    "customQuery": null,
    "info": "Despite its name, a **Hidden Item** will still have its definition and value rendered in the underlying HTML of a page. This allows for a malicious user to both view and edit the value and submit it back to APEX for processing, allowing for the update of unintended records.\n\nFortunately, Hidden Items in APEX contain an attribute called Value Protected. When enabled, if the value of a Hidden Item has been manipulated at all, APEX will reject the page submission and generate an error.\n\nThe Value Protected attribute is set to Yes by default, and should be left that way. The only exception to this is when the value of Hidden Item needs to be altered by either JavaScript or a Dynamic Action. If that is the case, and Value Protected is set to No, then additional validations should be made to ensure that the value set was a valid one, not a malicious one.",
    "fix": "To ensure that a **Hidden Item** is protected:\n\n1.  Edit a Hidden page item.\n2.  In the Settings region, set the value of Value Protected to **Yes**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "HTML Escaping Mode",
    "ruleKey": "HTML_ESCAPING_MODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "HTML_ESCAPING_MODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Extended",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "Traditionally, APEX has depended on the htf.escape\\_sc function to escape HTML before rendering in certain places. While this approach does work, it is somewhat limited in scope as to what gets escaped, as it will only escape the following characters:\n\n*   &\n*   \"\n*   \\<\n*   \\>\n\n   \nWhen set to **Basic**, the **HTML Escaping Mode** will function as if it were calling htf.escape\\_sc, and only escape the four characters listed above. Setting it to Extended mode will escape all characters in Basic mode as well as the following characters:\n\n*   &\n*   \"\n*   \\<\n*   \\>\n*   '\n*   /\n*   Non-ASCII characters\n\nAdditionally, **Extended** mode will also escape non-ASCII characters if the database character set is not set to AL32UTF8. By default, existing applications will have this value set to Basic, and new applications will have it set to Extended. It is recommended to set it to Extended, but only after thorough testing is conducted and functionality is not broken because of the change.\n\nNote: This feature is only available when the Compatibility Mode attribute is set to 4.1 or greater.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Browser Security** area, locate **HTML Escaping Mode** attribute and set its value to Extended.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "HTTP Response Headers",
    "ruleKey": "HTTP_RESPONSE_HEADERS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "HTTP_RESPONSE_HEADERS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **HTTP Response Headers** attribute allows a developer to supplement what APEX sends to the browser as part of the response header. This is a more advanced feature of APEX, and is unlikely to be used in most applications.",
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Include jQuery Migrate",
    "ruleKey": "INCLUDE_JQUERY_MIGRATE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A06-2021",
    "riskName": "Vulnerable and Outdated Components",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-user-interface-attributes.html#GUID-B2B87317-8178-4C82-A4B4-831132EB8A9F",
    "builderUrlKey": "APPLICATION_USER_INTERFACE",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_USER_INTERFACES",
    "columnToEvaluate": "INCLUDE_JQUERY_MIGRATE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This setting specifies if the **jQuery Migrate** plug-in should be included on every page in the application.\n\nThe plug-in restores deprecated features and behaviors of jQuery so that old JavaScript code and jQuery plug-ins will still run properly with the jQuery version loaded by Oracle APEX.\n\nIf you are confident your application and any used jQuery plug-in does not contain any references to deprecated jQuery features, set this to **Off** to reduce the overall size of the JavaScript files loaded.",
    "fix": "Navigate to your Application Definition, and select **User Interface tab**.\n\nIn **Javascript** area, locate **Include jQuery Migrate** attribute and use the slider to set its value to **Off**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Include Legacy Javascript",
    "ruleKey": "INCLUDE_LEGACY_JAVASCRIPT",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A06-2021",
    "riskName": "Vulnerable and Outdated Components",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-user-interface-attributes.html#GUID-B2B87317-8178-4C82-A4B4-831132EB8A9F",
    "builderUrlKey": "APPLICATION_USER_INTERFACE",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_USER_INTERFACES",
    "columnToEvaluate": "INCLUDE_LEGACY_JAVASCRIPT",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This setting specifies if deprecated or desupported **JavaScript** functions are included on every page in the application. \n\nThe functions deprecated or desupported are listed in the Release Notes for every release. \n\nIf you are confident your application does not contain any references to those deprecated or desupported functions, **don't check any checkbox** to reduce the overall size of the JavaScript files loaded.",
    "fix": "Navigate to your Application Definition, and select **User Interface tab**.\n\nIn **Javascript** area, locate **Include Deprecated or Desupported Javascript Functions** attribute and set both Pre 18.1 and 18.x  checkbox values to **Off**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Initialization PL/SQL Code",
    "ruleKey": "INITIALIZATION_PLSQL_CODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-F2324900-0AD3-4C0A-8B86-AE4B9C25F991",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "DB_SESSION_INIT_CODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Initialization PL/SQL Code** is typically used to set the security context of an application. The PL/SQL placed here will execute before anything else on each and every page within your application.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Database Session** area, examine **Initialization PL/SQL Code** attribute for reported SQL Injections issues. In particular, check usage of DBMS\\_SQL, EXECUTE\\_IMMEDIATE and incorrect item substitution syntax.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Grid Column AuthZ Inconsistency",
    "ruleKey": "INTERACTIVE_GRID_COLUMN_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) as target_page_id\n  ,ic.region_name\n  ,ic.region_id\n  ,ic.name as column_alias\n  ,ic.authorization_scheme\n  ,ic.authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_appl_page_ig_columns ic\nwhere 1=1\n  and ic.item_type = 'NATIVE_LINK'\n  and ic.link_target is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,c.column_alias as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'IG Column: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\n\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "APEX-SERT flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the Page. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Grid SQLi",
    "ruleKey": "INTERACTIVE_GRID_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_IG'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Grid WHERE Clause SQLi",
    "ruleKey": "INTERACTIVE_GRID_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_IG'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Column AuthZ Inconsistency",
    "ruleKey": "INTERACTIVE_REPORT_COLUMN_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/providing-security-through-authorization.html#GUID-8FBF5F46-0541-4859-8470-D10E333DD271",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2) as target_page_id\n  ,ic.region_name\n  ,ic.region_id\n  ,ic.column_alias\n  ,coalesce( ic.authorization_scheme,r.authorization_scheme) as authorization_scheme\n  ,coalesce( ic.authorization_scheme_id, r.authorization_scheme_id) as authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_application_page_ir_col ic\n  ,apex_application_page_regions r\nwhere 1=1\n  and ic.region_id = r.region_id \n  and ic.column_link is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,c.column_alias as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'IR Column: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Column Escaped",
    "ruleKey": "INTERACTIVE_REPORT_COLUMN_ESCAPED",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_IR_COL",
    "columnToEvaluate": "DISPLAY_TEXT_AS",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": "COLUMN_ALIAS",
    "itemName": null,
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "WITHOUT_MODIFICATION",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Interactive Report** columns can render HTML as part of their item. In this case, it is important to ensure that the HTML rendered is properly escaped, so that in the case the HTML contains malicious code, it is rendered harmless.\n\n**Interactive Report** columns contain a property called **Escape Special Characters**. When set to **Yes**, any HTML rendered on the page will be properly escaped. When set to **No**, any HTML will be rendered as-is, introducing the risk of malicious code getting executed. Thus, it is recommended to set this **Enable Special Characters** to **Yes**.",
    "fix": "To change the **Escape Special Characters** attribute for an **Interactive Report** column:\n\n1.  Edit the corresponding page of your application that contains the report in question.\n2.  Expand the Report in the Rendering panel, click on the Tree View toggle next to the affected report.\n3.  Select the column in question.\n4.  In the Column Attribute panel/region, locate the **Security section**, and toggle the switch **Escape Special Characters** attribute to **Yes**.\n5.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Link AuthZ Inconsistency",
    "ruleKey": "INTERACTIVE_REPORT_LINK_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   application_id\n  ,page_id\n  ,REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2) as target_page_id\n  ,region_name\n  ,region_id\n  ,detail_link_auth_scheme as authorization_scheme\n  ,detail_link_auth_scheme_id as authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_application_page_ir\nwhere 1=1\n  and detail_link_type = 'Custom Link target'\n  and application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'IR Link: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\n\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Link Text &ITEM. Syntax",
    "ruleKey": "INTERACTIVE_REPORT_LINK_TEXT_ITEM_SYNTAX",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/cross-site-scripting-protection.html#GUID-DC111134-6369-4424-8DAD-BB9649F9B03F",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_IR_COL",
    "columnToEvaluate": "COLUMN_LINKTEXT",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": "COLUMN_ALIAS",
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "XSS_ITEM_SYNTAX",
    "additionalWhere": null,
    "customQuery": null,
    "info": "Use of **&ITEM.** syntax can potentially leave an application open to **SQL Injection** attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the variables will be replaced verbatim with the variable value. For example, suppose there is a a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n**SELECT COUNT(\\*) FROM users WHERE username = '&USERNAME.' AND password = '&PASSWORD.'**\n\nIf the user were to enter this as their password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nThe resulting SQL would be:\n\n**SELECT COUNT(\\*) FROM users WHERE username = 'SCOTT' AND password = 'i\\_dont\\_know' OR 'x' = 'x'**\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.  \nBy using bind variables, this can be avoided.\n\n**SELECT COUNT(\\*) FROM users WHERE username = :USERNAME AND password = :PASSWORD**\n\nNow, if you enter this as your password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nUnless that is specifically your password, the database will return _**No Data Found**_.\n\nWhile it may not be optimal performance-wise, the following items can safely be used with the **&ITEM\\_NAME.** syntax, as they are all APEX built-in items and can not be changed by an end-user:\n\n*   **APP\\_ID**\n*   **APP\\_ALIAS**\n*   **APP\\_PAGE\\_ID**\n*   **APP\\_USER**\n*   **SESSION**\n*   **DEBUG**\n\n**APEX-SERT** will also ignore items that use the &ITEM\\_NAME. syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "To change the **Link Column** attribute for an **Interactive Report** column:\n\n1.  Edit the corresponding page of your application that contains the report in question.\n2.  Expand the Report in the Rendering panel, click on the Tree View toggle next to the affected report.\n3.  Select the column in question.\n4.  In the Column Attribute panel/region, locate the **Link section**\n5.  Ensure that the **&ITEM.** reference is to a page item or an application item, and that the value of that item is properly escaped (**Escape Special Characters** attribute to **Yes)**. Otherwise, remove any reference to that item.\n6.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report SQLi",
    "ruleKey": "INTERACTIVE_REPORT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'DYNAMIC_QUERY'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report WHERE Clause SQLi",
    "ruleKey": "INTERACTIVE_REPORT_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'DYNAMIC_QUERY'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Item Default SQLi",
    "ruleKey": "ITEM_DEFAULT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ITEM_DEFAULT",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and item_default is not null\nand item_default_type in \n  (\n   'SQL_QUERY'\n  ,'SQL_QUERY_COLON'\n  ,'EXPRESSION'\n  ,'FUNCTION_BODY'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Item** in the Page Rendering tree, and edit its **PL/SQL Function Body** in the **Default** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Item Session State Protection Level",
    "ruleKey": "ITEM_SESSION_STATE_PROTECTION_LEVEL",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-D3ECB171-681E-4452-BB33-5E74EC0EE13E",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ITEM_PROTECTION_LEVEL",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "Unrestricted",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and display_as_code = 'NATIVE_HIDDEN'",
    "customQuery": null,
    "info": "This attribute identifies the total number ofItems that have their Session State Protection attribute set to Unrestricted for an application. These unrestricteditems can be manipulated via the URL by a malicious user, causing potentially disastrousresults.\n\nThere are four possible values for Session State Protection at the item level:\n\n*   **Unrestricted**  \n    The item may be set via the URL with no restrictions.\n*   **Restricted - may not be set from browser**  \n    The item can not be set via the URL. This value only applies to the following item types:  \n        - Display as Text (escape special characters, does not save state)  \n        - Display as Text (does not save state)  \n        - Display as Text (based on LOV, does not save state)  \n        - Display as Text (based on PLSQL, does not save state)  \n        - Text Field (Disabled, does not save state)  \n        - Stop and Start HTML Table (Displays label only)\n*   **Checksum Required - Application Level**  \n    The item can be set via the URL provided an application-level checksum is present in the URL.\n*   **Checksum Required - User Level**  \n    The item can be set via the URL provided a user-level checksum is present in the URL.\n*   **Checksum Required - Session Level**  \n    The item can be set via the URL provided a session-level checksum is present in the URL.\n\nIt is broken down by page in the summary report. To see which items Session State Protection is set to Unrestricted, click on the View link for the corresponding page.\n\nKeep in mind that Session State Protection must be enabled at the application level for this attribute to work properly.",
    "fix": "To change the **Session State Protection** attribute for a **Page Item**:\n\n1.  Edit a page item in your application that you wish to enable Session State Protection.\n2.  In the Security region, set the Session State Protection attribute to any value other than **Unrestricted**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Item Source SQLi",
    "ruleKey": "ITEM_SOURCE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ITEM_SOURCE",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and item_source is not null\nand item_source_type in \n  (\n   'SQL Query (return single value)'\n  ,'SQL Query (return colon separated value)'\n  ,'Expression'\n  ,'Function Body'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Item** in the Page Rendering tree, and edit its **PL/SQL Function Body** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Legacy Region Types",
    "ruleKey": "LEGACY_REGION_TYPES",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-app-legacy-components.html",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "SOURCE_TYPE_CODE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "CALENDAR:PLSQL_PROCEDURE:DATA_UPLOAD_COLUMN_MAPPING",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "Oracle still supports L**egacy** page **region types**, but does not recommend using them.",
    "fix": "To verify the **Legacy Page Region Type** attribute:\n\n1.  Edit the corresponding page of your application and navigate to the **region** in question.\n2.  In the Identification region, locate the **Type** attribute.\n3.  Ensure the **Legacy** region type is not used.\n4.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List Entry AuthZ Inconsistency",
    "ruleKey": "LIST_ENTRY_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "LIST",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   le.application_id\n  ,null as page_id\n  -- substr 5: after the 'f?p='\n  ,REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) as target_app_id\n  ,REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2) as target_page_id\n  ,le.list_name\n  ,le.entry_text\n  ,le.authorization_scheme\n  ,le.authorization_scheme_id\n  ,le.list_entry_id\n  ,(select app_page.authorization_scheme\n      from apex_applications app\n      join apex_application_pages app_page on (app.application_id = app_page.application_id)\n      where to_char(app_page.page_id) = REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2) \n      and REGEXP_LIKE(REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n      and (to_char(app.application_id) = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or app.alias = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or (REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) = '&APP_ID.' and to_char(app.application_id) = #APP_ID#)) \n    ) target_authorization_scheme\n    ,(select app_page.authorization_scheme_id\n      from apex_applications app\n      join apex_application_pages app_page on (app.application_id = app_page.application_id)\n      where to_char(app_page.page_id) = REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2) \n      and REGEXP_LIKE(REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n      and (to_char(app.application_id) = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or app.alias = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or (REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) = '&APP_ID.' and to_char(app.application_id) = #APP_ID#)) \n    ) target_authorization_scheme_id\nfrom\n   apex_application_list_entries le\nwhere 1=1\n  and le.entry_target is not null\n  and le.entry_target like 'f?p%'\n  and le.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,null as page_id \n  ,c.list_entry_id component_id \n  ,c.entry_text as component_name\n  ,null as column_name \n  ,null as item_name\n  ,list_name as shared_comp_name\n  ,'List Entry: ' || nvl(c.authorization_scheme,'None') || ' / Page: ' || nvl(c.target_authorization_scheme,'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(c.target_authorization_scheme_id,0) = nvl(c.authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n    end as result\nfrom c\nwhere 1=1\n  and c.application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **List Entries** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **List Entries** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List Entry Does Not Contain &ITEM. Syntax",
    "ruleKey": "LIST_ENTRY_DOES_NOT_CONTAIN_ITEM_SYNTAX",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/creating-lists.html#GUID-0ABE095F-AE4D-438C-840E-3B47915E6109",
    "builderUrlKey": "LIST",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LIST_ENTRIES",
    "columnToEvaluate": "ENTRY_TEXT",
    "componentId": "LIST_ID",
    "componentName": "ENTRY_TEXT",
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "XSS_ITEM_SYNTAX",
    "additionalWhere": null,
    "customQuery": null,
    "info": "Use of **&ITEM.** syntax can potentially leave an application open to **SQL Injection** attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n**SELECT COUNT(\\*) FROM users WHERE username = '&USERNAME.' AND password = '&PASSWORD.'**\n\nIf the user were to enter this as their password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nThe resulting SQL would be:\n\n**SELECT COUNT(\\*) FROM users WHERE username = 'SCOTT' AND password = 'i\\_dont\\_know' OR 'x' = 'x'**\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.  \nBy using bind variables, this can be avoided.\n\n**SELECT COUNT(\\*) FROM users WHERE username = :USERNAME AND password = :PASSWORD**\n\nNow, if you enter this as your password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nUnless that is specifically your password, the database will return _**No Data Found**_.\n\nWhile it may not be optimal performance-wise, the following items can safely be used with the **&ITEM\\_NAME.** syntax, as they are all APEX built-in items and can not be changed by an end-user:\n\n*   **APP\\_ID**\n*   **APP\\_ALIAS**\n*   **APP\\_PAGE\\_ID**\n*   **APP\\_USER**\n*   **SESSION**\n*   **DEBUG**\n\n**APEX-SERT** will also ignore items that use the &ITEM\\_NAME. syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "To change the attributes for a **List Entry**:\n\n1.  Edit your application's **Shared Components**.\n2.  In the Shared Component region, click your List.\n3.  Click the List entry you wish to modify.\n4.  Examine each reference using the **&ITEM.** syntax. See below for details.\n5.  Click **Apply Changes**.\n\nExamine the code for uses of **&ITEM.** syntax and, wherever possible, replace the usage with:\n\n*   **:ITEM\\_NAME** bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   **v('ITEM\\_NAME')** syntax\n    *   in stored PL/SQL program units called from APEX\n*   **ITEM\\_NAME** syntax\n    *   in conditions\n*   **&ITEM\\_NAME.**\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the **&ITEM.** syntax is necessary, developers can mitigate much of the risk by using **HTF.ESCAPE\\_SC** to escape the referenced item.\n\n_**Caution**: Use of **&ITEM.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List of Values SQLi",
    "ruleKey": "LIST_OF_VALUES_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "LOV",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LOVS",
    "columnToEvaluate": "LIST_OF_VALUES_QUERY",
    "componentId": "LOV_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_OF_VALUES_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and source_type_code in ('FUNC_BODY_RETURNING_SQL','SQL')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **List of Values** definition in question, and edit its **SQL Query** code in the **Source** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List of Values WHERE Clause SQLi",
    "ruleKey": "LIST_OF_VALUES_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "LOV",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LOVS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "LOV_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_OF_VALUES_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **List of Values** definition in question, and edit its **Where Clause** code in the **Source** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List SQLi",
    "ruleKey": "LIST_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "LIST",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LISTS",
    "columnToEvaluate": "LIST_QUERY",
    "componentId": "LIST_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and list_query is not null\nand list_type_code = 'SQL_QUERY'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **List** definition in question, and edit its **Query** in the **List Query** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Logging",
    "ruleKey": "LOGGING",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-583B8D2A-D236-4A35-A510-F87BF3C694FA",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "LOGGING",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Logging** attribute determines whether or not APEXwill write information to two log tables:\n\n*   **APEX\\_WORKSPACE\\_ACCESS\\_LOG**  \n    This log records all access attempts - successful or otherwise - made to any APEXapplication. It includes the user name, date of attempt, IPAddress, among other details about each access attempt. When using a custom authentication scheme, you can augment this log with the APEX\\_UTIL.SET\\_AUTHENTICATION\\_RESULT and APEX\\_UTIL.SET\\_CUSTOM\\_AUTH\\_STATUS APIs.  \n    undefined\n*   **APEX\\_WORKSPACE\\_ACTIVITY\\_LOG**  \n    This log records all page views which occur within your workspace. It includes all pertinent details about each page view, including user name and session, timestamp, IP address, browser, and associated error messages.\n\nAPEX logs are purged roughly every two weeks by default. APEX will retain high-level information from its logs, but this is often times not detailed enough for most organizations. Thus, itis recommended that you configure a custom archival mechanism to preserve all data stored in the logs.",
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map Layer SQLi",
    "ruleKey": "MAP_LAYER_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_PAGE_MAP_LAYERS",
    "columnToEvaluate": "LAYER_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and layer_source is not null",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map Layer WHERE Clause SQLi",
    "ruleKey": "MAP_LAYER_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_PAGE_MAP_LAYERS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map SQLi",
    "ruleKey": "MAP_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_MAP_REGION'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map WHERE Clause SQLi",
    "ruleKey": "MAP_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_MAP_REGION'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Maximum Row Count",
    "ruleKey": "MAXIMUM_ROW_COUNT",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/developing-reports.html#GUID-A63ECD33-D759-4725-9666-A02719FB35B8",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "select \n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,r.application_id as application_id\n  ,r.page_id page_id \n  ,r.region_id as component_id\n  ,null as component_name \n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,nvl(r.maximum_row_count, 500) as current_value\n  ,'Less or Equal to than 500' as valid_values\n  ,case \n     when nvl(r.maximum_row_count, 500) < 501 then '{\"result\":\"PASS\"}' \n     else '{\"result\":\"FAIL\"}' \n     end as result \nfrom\n  apex_application_page_rpt rpt\n ,apex_application_page_regions r \nwhere \n  rpt.region_id = r.region_id",
    "info": "The **Maximum Row Count** of a report dictates the maximum number of rows that will be retrieved from the database. A high Maximum Row Count could allow a user to access and export large amounts of data and walk away with it.\n\nDuring normal system use, most users will be working with the first few hundred rows of data in a report and will never navigate past the first few pages. It is an advantage, not only for security but also for performance reasons to keep the **Maximum Row Count** as low as possible.",
    "fix": "To set the **Maximum Row Count**:  \n**Classic Reports**\n\n1.  Select the Attributes node of the corresponding Classic Report.\n2.  In the Advanced region, set `Maximum Row Count` to the desired value.\n3.  Click **Save**.\n\n---\n\n**Interactive Reports:**\n\n1.  Select the Attributes node of the corresponding Interactive Report.\n2.  In the Advanced region, set the value of `Maximum Row Count` to the desired value.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Maximum Session Idle Time",
    "ruleKey": "MAXIMUM_SESSION_IDLE_TIME",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "MAXIMUM_SESSION_IDLE_SECONDS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "LESS_THAN",
    "valChar": null,
    "valNumber": 3601,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Maximum Session Idle** attribute determines how long - in seconds, not minutes - an APEX session can be idle before it is automatically timed out.\n\nIf this value is set to NULL, then APEX will not check for idle time, thus enabling a user to be idle for as long as the Maximum Session Length permits.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session Management** area, locate **Maximum Session Idle Time in Seconds** attribute and change its value to between 0 and 3600.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Maximum Session Length",
    "ruleKey": "MAXIMUM_SESSION_LENGTH",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "MAXIMUM_SESSION_LIFE_SECONDS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "LESS_THAN",
    "valChar": null,
    "valNumber": 28801,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Maximum Session Length** attribute determines how long - in seconds, not minutes - an APEX session will be valid before it is automatically timed out.\n\nIf this value is set to NULL, then the session will be good indefinitely. However, by default, all APEX sessions older than 8 hours are purged every 24 hours. Thus, unless the frequency of this job is changed, the longest APEX session possible is closer to 8 hours.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session Management** area, locate **Maximum Session Length in Seconds** attribute and change its value to between 0 and 28800.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Max Rows to Query - Classic Report",
    "ruleKey": "MAX_ROWS_TO_QUERY_CLASSIC_REPORT",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-classic-reports.html#GUID-6C9E3F69-691B-4501-8020-097C92508561",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "MAXIMUM_ROWS_TO_QUERY",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "LESS_THAN",
    "valChar": null,
    "valNumber": 1000,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and source_type_code = 'SQL_QUERY'",
    "customQuery": null,
    "info": "The **Max Rows to Query** is the Classic Report **Number of Rows** attribute that represents a number of rows to display per **report page**. It is the pagination page size. \n\nFor performance reasons keep the **Max Rows to Query** value below 1000.",
    "fix": "To set the **Max Rows to Query** in a Classic Report:\n\n1.  Edit the corresponding page of your application and navigate to the Classic Report in question.\n2.  Select the Attributes node of the report.\n3.  In the Layout region, set **Number of Rows** to the value less than 1000.\n4.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Media List SQLi",
    "ruleKey": "MEDIA_LIST_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$MEDIA_LIST'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Media List WHERE Clause SQLi",
    "ruleKey": "MEDIA_LIST_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$MEDIA_LIST'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "On Demand Application Process with No AuthZ",
    "ruleKey": "ON_DEMAND_APPLICATION_PROCESS_WITH_NO_AUTHZ",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "APP_PROCESS",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PROCESSES",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": "APPLICATION_PROCESS_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "PROCESS_NAME",
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and process_point = 'On Load: Before Header (page template header)'",
    "customQuery": null,
    "info": "Like most components in APEX, an On demand Application Process can have an **Authorization Scheme**.  By associating the **Authorization Scheme** with the On demand Application Process, only those users who are members of the corresponding **Authorization Scheme** will be able to run the process.\n\nThis technique is critical when using a central **Authentication Scheme**, such as LDAP. Without an application-level **Authorization Scheme**, any user in the LDAP directory will be able to run the process. Thus, it's a best practice to create a group - either in LDAP or via database tables - and add authorized users to that group. The application **Authorization Scheme** can then check to see if a user is a member of the associated group or not, thus either allowing them or preventing them from running the process.",
    "fix": "To associate an **Authorization Scheme** with an On Demand Application Process:\n\n1.  Edit your On Demand Application Process in **Shared Components**.\n2.  In the Authorization region, set the value of Authorization Scheme to any appropriate value except for **No Authorization Required**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "On Demand Page Process with No AuthZ",
    "ruleKey": "ON_DEMAND_PAGE_PROCESS_WITH_NO_AUTHZ",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "PAGE_PROCESS",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_PROC",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": "PROCESS_ID",
    "componentName": "PROCESS_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and process_point_code = 'ON_DEMAND'",
    "customQuery": null,
    "info": "Like most components in APEX, an On demand Page Process can have an **Authorization Scheme**.  By associating the **Authorization Scheme** with the On demand Page Process, only those users who are members of the corresponding **Authorization Scheme** will be able to execute the process.",
    "fix": "To associate an **Authorization Scheme** with an On Demand Page Process:\n\n1.  Edit the page and locate the **On Demand Page Process** in question. \n2.  Click on the process name in the _Page Rendering_ tree.\n3.  In the **Security** Region, set the **Authorization Scheme** attribute to any appropriate non NULL value.\n4.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Access Protection",
    "ruleKey": "PAGE_ACCESS_PROTECTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/preventing-url-tampering.html#GUID-C47B5B4C-FA49-47C7-BAAE-6D5A06DE029C",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "PAGE_ACCESS_PROTECTION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Arguments Must Have Checksum:No URL Access:No Arguments Allowed",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "Each page in an APEX application has an attribute called **Page Access Protection**. This attribute determines how a page can be accessed, and whether or not you can pass item values to the page.\n\nThere are four modes for **Page Access Protection**:\n\n*   **Unrestricted**  \n    This page can be accessed via the URL and all URL parameters (request, session state, item values) are allowed\n*   **Arguments Must Have Checksum**\n*   URL parameters ( request, session state, item values)can only be passed to this page if a corresponding checksum is also present in the URL. Individual items must also be protected at either the session, user or application level.\n*   **No Arguments Supported**  \n    URL parameters (request, session state, item values) for this page are prohibited, but the page can still be accessed via entering its corresponding URL.\n*   **No URL Access**  \n    Not only are URL parameters (request, session state, item values) prohibited, but the only way to access this page is the result of an APEX branch.\n\nBy default, all APEX pages are created with this attribute set to Unrestricted. That means that users can pass values to any of the URL parameters on any APEX page unless you take time to change this attribute.\n\nIf you elect to use Arguments Must Have Checksum, then enabling this attribute is only part one of a two step process. You should take care to enable the corresponding attribute for each item that you wish to protect on this page.",
    "fix": "To modify the **Page Access Protection** attribute:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the _Page Rendering_ tree.\n2.  In the Security Region, set the **Page Access Protection** attribute to anything except **Unrestricted**.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Authorization Scheme",
    "ruleKey": "PAGE_AUTHORIZATION_SCHEME",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A01-2021",
    "riskName": "Broken Access Control",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/providing-security-through-authorization.html#GUID-8FBF5F46-0541-4859-8470-D10E333DD271",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0 \nand page_template <> 'Login'",
    "customQuery": null,
    "info": "Setting an **Authorization Scheme** at the page level is just as critical as setting one at the application level. Page-level authorization schemes restrict which authenticated users can see which pages. Quite often, applications will contain more than one role, and need to be secured so that users from one role can not see pages associated with other roles. Thus, each page should be associated with an **Authorization Scheme**, thus securing the page and all of its associated content.\n\nOften, developers will only associate the authorization scheme with a tab, link or button. This will only hide the corresponding table, link or button; it will do nothing to stop a malicious user from changing the URL to view potentially sensitive pages that they are not supposed to see.",
    "fix": "To associate an **Authorization Scheme** with a page:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, set the value of **Authorization Scheme** to the corresponding Authorization Scheme that you want to associate with this page.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Caching",
    "ruleKey": "PAGE_CACHING",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-page-attributes-in-page-designer.html#GUID-5CF0B715-7A6B-4A49-B14B-471CCA2C775C",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "CACHED",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "**Page Caching**  \nSelect how the Oracle APEX engine can **cache** HTML text on the server side. If caching can be used, it emits the cached result instead of computing it again. This cuts down on expensive computation time on the server. This feature is unrelated to the browser's caching capabilities.\n\nAvailable options include:  \nDisabled - Content is not cached and computed for each request.  \nEnabled - Content is cached and utilized by all users.  \nCache By User - Content is cached specifically for each user.  \nCache By Session - Content is cached specifically for each session.\n\nFrom a security standpoint, **Page Caching** should be **Disabled** so that page specific sensitive information will not be kept at the browser level. It will also ensure that information displayed is up to date.",
    "fix": "To modify the **Page Caching** attribute:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the _Page Rendering_ tree.\n2.  In the **Server Cache** Region, set the **Caching** attribute to **Disabled**.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Computation SQLi",
    "ruleKey": "PAGE_COMPUTATION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_COMPUTATION",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": "select\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id page_id \n  ,c.computation_id as component_id \n  ,null as component_name\n  ,null as column_name \n  ,c.item_name || ' / ' || c.computation_type as item_name\n  ,null as shared_comp_name\n  ,c.computation as current_value\n  ,'Criteria ' as valid_values\n  ,eval_pkg.eval_criteria(p_column_to_evaluate => COMPUTATION, p_rule_criteria_type_key => 'SQLI', p_application_id => #APP_ID#) as result \nfrom\n   apex_application_page_comp c\n  ,apex_application_page_items i\n ,apex_application_page_regions r \nwhere 1=1 \n  and c.application_id = #APP_ID# \n  and c.computation_type in ('SQL Query (return single value)','SQL Query (return colon separated value)','Expression','Function Body')\n  and c.item_name = i.item_name\n  and c.application_id = i.application_id\n  and i.region_id = r.region_id(+)",
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Computation** in the Page Rendering tree, and edit its **PL/SQL Function Body** in the **Computation** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Item Encryption",
    "ruleKey": "PAGE_ITEM_ENCRYPTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A02-2021",
    "riskName": "Cryptographic Failures",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-page-items.html#GUID-C89752E5-6CAD-49DF-9ED7-6DDAFC491F95",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ENCRYPT_SESSION_STATE",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "When users fill out a form in APEX, the data that is sent back to the server is stored unencrypted in the APEX session table - WWV\\_FLOW\\_DATA. While there are adequate precautions taken to ensure that other users can not see this data, there is nothing to stop an APEX workspace administrator or DBA from seeing it.\n\nThus, you should consider applying **Item Level Encryption** to any item that could contain sensitive data. With this feature enabled, the values of items in APEX session state are encrypted before they are stored, preventing APEX workspace administrator and even DBAs from snooping. \n\nEnabling this feature requires no additional changes to your APEX applications. You can still refer to encrypted items the same way you would refer to unencrypted ones. APEX will automatically encrypt and decrypt them for you.\n\nNote: Application Items do not currently support this feature. Thus, if you need to store data in an encrypted fashion, you should use Page 0 items instead.",
    "fix": "To enable **item-level encryption**:\n\n1.  Edit a page item in your application that you wish to enable item-level encryption.\n2.  In the Security region, set the value of **Store value encrypted in session state** to **Yes**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Process SQLi",
    "ruleKey": "PAGE_PROCESS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_PROCESS",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_PROC",
    "columnToEvaluate": "PROCESS_SOURCE",
    "componentId": "PROCESS_ID",
    "componentName": "PROCESS_NAME:PROCESS_POINT",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and process_type_code = 'PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Process** in the Page Rendering tree, and edit its **PL/SQL Code** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Requires Authentication",
    "ruleKey": "PAGE_REQUIRES_AUTHENTICATION",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/establishing-user-identity-through-authentication.html#GUID-45C4B1CD-4231-4FE9-8B5B-C90611F5F57B",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "PAGE_REQUIRES_AUTHENTICATION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "The **Authentication** page attribute determines whether a user needs to be authenticated or not in order to see the page. No specific membership or Authorization Scheme is required.\n\nIf you need some pages to be public - in that anyone will be able to view them - you can set this attribute to Page is Public. Otherwise, all pages in your application should have this set to Page Requires Authentication.",
    "fix": "To change the Authentication page-level attribute:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, set the value of Authentication to **Page Requires Authentication**.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Process Button AuthZ Inconsistency",
    "ruleKey": "PROCESS_BUTTON_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\r\n(\r\nselect\r\n   application_id\r\n  ,button_name\r\n  ,button_id\r\n  ,authorization_scheme\r\n  ,authorization_scheme_id\r\nfrom\r\n   apex_application_page_buttons\r\nwhere 1=1\r\n  and authorization_scheme_id is not null\r\n  and application_id = #APP_ID#\r\n)\r\nselect\r\n   #EVAL_ID# as eval_id\r\n  ,#RULE_ID# as rule_id \r\n  ,c.application_id as application_id\r\n  ,page_id as page_id \r\n  ,p.process_id component_id \r\n  ,c.button_name || ' => ' || p.process_name as component_name\r\n  ,null as column_name \r\n  ,null as item_name\r\n  ,null as shared_comp_name\r\n  ,'Button: ' || nvl(c.authorization_scheme,'None') || ' / Process: ' || nvl(p.authorization_scheme,'None') as current_value\r\n  ,'AuthZ Schemes Match' as valid_values\r\n  ,case when nvl(p.authorization_scheme_id,0) = nvl(c.authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' end as result\r\nfrom\r\n   apex_application_page_proc p\r\n  ,c\r\nwhere 1=1\r\n  and p.application_id = #APP_ID#\r\n  and p.when_button_pressed_id = c.button_id",
    "info": "The execution of a **Page Processes** can be linked to the click of a specific **Button** on the same page. When the **Authorization Schemes** of the Process and the Button do not match it might be possible for the user to have access to the Button and not the Process or vice versa.\r\n\r\n**APEX-SERT** flags **Page Processes** where the execution is tied to a Button, but where the Button's Authorization scheme doesn't match the Authorization Scheme for the Process.",
    "fix": "Check the Authorization Schemes on both the driving Button and the Page Process for compatibility. \r\n\r\nAlthough they are not _required_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provide the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Referrer Policy",
    "ruleKey": "REFERRER_POLICY",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-5AEB6EEF-A89B-41B6-B8D5-00A0FD926E8F",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "REFERRER_POLICY",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "strict-origin",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This attribute defines what Oracle APEX sends in the **Referrer-Policy** HTTP response header. Referrer-Policy controls what the browser sends to servers in the **Referer** and **Origin** request headers, when users click on links or submit pages. \n\nNormally, this information includes the full URL, including Oracle APEX session IDs, which should not be exposed to third parties. New applications should use the value **strict-origin**, unless there are specific business requirements for a different setting.\n\nPlease see the [documentation for the Referrer-Policy header and its available values](https://www.w3.org/TR/referrer-policy/) for further information.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Browser Security** area, locate **Referrer Policy** attribute and change its value to **strict-origin**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Reflow Report SQLi",
    "ruleKey": "REFLOW_REPORT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_JQM_REFLOW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Reflow Report WHERE Clause SQLi",
    "ruleKey": "REFLOW_REPORT_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_JQM_REFLOW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Rejoin Sessions",
    "ruleKey": "REJOIN_SESSIONS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A01-2021",
    "riskName": "Broken Access Control",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/editing-page-attributes-in-page-designer.html#GUID-C5DC542A-6963-43AB-AA35-26FDC0730B18",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "REJOIN_EXISTING_SESSIONS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Disabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "The **Rejoin Sessions** attribute will allow users to rejoin a previously established session without providing a Session ID. APEX will only use the existing cookie to determine whether or not to consider the current session as valid.\n\nEnabling this option does present a security risk, albeint a minimum one.  A hacker would still need to be able to gain access to and replicate an APEX session cookie to hijack a session. Ideally, if not needed, this option should be set to **Disabled**.",
    "fix": "To alter the value of **Rejoin Sessions** for a specific page:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, set the value for Rejoin Sessions to **Disabled**. Alternatively, if the Application Level setting is set to **Disabled**, then set it to **Application Default**.\n3.  Click **Save**.Rejoin Sessions has four possible settings at the page level:\n    1.  **Application Default** - This will take its value from the current application's Rejoin Sessions attribute.\n    2.  **Disabled** - Sessions cannot be rejoined at all\n    3.  **Enabled for Public Sessions** - APEX will attempt to rejoin an existing session only when navigating to a page that is publicly accessible.",
    "timeToFix": null,
    "ruleSeverityName": "Low",
    "ruleSeverityKey": "LOW",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Runtime API Usage",
    "ruleKey": "RUNTIME_API_USAGE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-F2324900-0AD3-4C0A-8B86-AE4B9C25F991",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "RUNTIME_API_USAGE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This attribute controls how this application can access Oracle APEX APIs that modify applications and workspace data, while it is running.\n\n*   Modify This Application: The application can modify itself.\n*   Modify Other Applications: The application can change other applications in the workspace.\n*   Modify Workspace Repository: The application can change workspace users and groups.\n\nUnless there is a specific requirement, It is recommended to have all three options set to **No**.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Advanced** area, locate **Runtime API Usage** attribute and change all 3 options to **No**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Run Authorization on Background Jobs",
    "ruleKey": "RUN_AUTHORIZATION_ON_BACKGROUND_JOBS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-69485470-823B-4CC0-9E11-1CF144054F53",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "AUTHORIZE_BATCH_JOB",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This attribute defines whether the authorization schemes at application, page, region and column level are checked in the background job such as interactive report subscriptions. Options include:\n\n*   **On** - If you select **On**, the authorization is checked.\n*   **Off** - If you select **Off**, the authorization is ignored.\n\nNote: The background job authorization check uses cloned session state instead of the current session state. The cloned session state does NOT include collection, report settings nor session state set during the post authentication process. The authorization check may fail if session state in cloned session is not found.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Authorization** area, locate **Run on Background Job** attribute and change its value to **Yes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Run Authorization on Public Pages",
    "ruleKey": "RUN_AUTHORIZATION_ON_PUBLIC_PAGES",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-69485470-823B-4CC0-9E11-1CF144054F53",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "AUTHORIZE_PUBLIC_PAGES",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "If a page is set to a Public Page, it is likely that the developer intended that page to always be available to anyone - regardless whether they are authenticated or not. However, if there is an Authorization Scheme associated with the application itself, it is possible that pages that intended to be public will not render, based on the result of the Authorization Scheme.\n\nIf this is the case, set **Run Authorization on Public Pages** to **No** so that pages that are set to public will bypass the application-level Authorization Scheme when rendering. If the Authorization Scheme still needs to be checked - even on public pages - then set set **Run Authorization on Public Pages** to **Yes**. Thus, the correct value of this attribute is largely dependent on the intended behavior of public pages, and is largely subjective.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Authorization** area, locate **Run on Public Pages** attribute and change its value to **Yes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Session State Protection",
    "ruleKey": "SESSION_STATE_PROTECTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-D3ECB171-681E-4452-BB33-5E74EC0EE13E",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "SESSION_STATE_PROTECTION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Enabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Session State Protection** attribute determines whether or not your application will provide support for the Session State Protection feature. Enabling it does not actually provide any protection. Each page and individual item must be configured for Session State Protection to work.\n\nIt is essential that **Session State Protection** be enabled and then configured in your application to prevent multiple types of attack.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session State Protection** area, locate **Session State Protection** attribute and set its value to **Enabled**.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Actions SQLi",
    "ruleKey": "TASK_DEFINITION_ACTIONS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEF_ACTIONS",
    "columnToEvaluate": "ACTION_CLOB",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "TASK_DEF_NAME:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and action_clob_language = 'PLSQL' and action_type_code = 'NATIVE_PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, select corresponding **Action**, and edit its **Code** in the **Code** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Actions SQL Query SQLi",
    "ruleKey": "TASK_DEFINITION_ACTIONS_SQL_QUERY_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEFS",
    "columnToEvaluate": "ACTIONS_SQL_QUERY",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and actions_sql_query is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, and edit its **Actions SQL Query** code in the **Settings** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Due On SQLi",
    "ruleKey": "TASK_DEFINITION_DUE_ON_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEFS",
    "columnToEvaluate": "DUE_ON_INTERVAL",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and due_on_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, and edit its **Due On** code in the **Deadline** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Parameter Value SQLi",
    "ruleKey": "TASK_DEFINITION_PARAMETER_VALUE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEF_COMP_PARAMS",
    "columnToEvaluate": "VALUE",
    "componentId": "COMPONENT_PARAMETER_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "COMPONENT_NAME:PARAM_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Participants SQLi",
    "ruleKey": "TASK_DEFINITION_PARTICIPANTS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEF_PARTICIPANTS",
    "columnToEvaluate": "VALUE",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "TASK_DEF_ID:TASK_DEF_NAME:PARTICIPANT_TYPE:VALUE_TYPE",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, select corresponding **Participant** in the Participants region, and edit its **Value**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Theme Component Action AuthZ Inconsistency",
    "ruleKey": "THEME_COMPONENT_ACTION_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) as target_page_id\n  ,ic.region_name\n  ,ic.region_id\n  ,nvl(label, position_name) || ' (' || ic.display_sequence || ')' as column_alias\n  ,coalesce( ic.authorization_scheme, r.authorization_scheme) as authorization_scheme\n  ,coalesce( ic.authorization_scheme_id, r.authorization_scheme_id) as authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_appl_page_comp_actions ic\n  ,apex_application_page_regions r\nwhere 1=1\n  and ic.region_id = r.region_id \n  and ic.link_target is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,c.column_alias as component_name\n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'Action: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\nfrom c\nwhere 1=1\n  and c.application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.\n\nWhen an theme component action uses a column substitution for the Action, it cannot be confirmed by APEX-SERT and will require an exception",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Timeline SQLi",
    "ruleKey": "TIMELINE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code in 'TMPL_THEME_42$TIMELINE'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Timeline WHERE Clause SQLi",
    "ruleKey": "TIMELINE_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$TIMELINE'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Validation SQLi",
    "ruleKey": "VALIDATION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "VALIDATION",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_VAL",
    "columnToEvaluate": "VALIDATION_EXPRESSION1",
    "componentId": "VALIDATION_ID",
    "componentName": "VALIDATION_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and validation_type_code in \n  (\n   'EXPRESSION'\n  ,'PLSQL_ERROR'\n  ,'FUNC_BODY_RETURNING_BOOLEAN'\n  ,'FUNC_BODY_RETURNING_ERR_TEXT'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Validation** in the Page Rendering tree, and edit its **PL/SQL Code raising Error** in the **Validation** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activities Additional Data SQLi",
    "ruleKey": "WORKFLOW_ACTIVITIES_ADDITIONAL_DATA_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACTIVITIES",
    "columnToEvaluate": "QUERY_SOURCE",
    "componentId": "ACTIVITY_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and query_source is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Activity** in the Workflow Rendering tree **Activities** List, and edit its **SQL Query** code in the **Additional Data** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activity Source SQLi",
    "ruleKey": "WORKFLOW_ACTIVITIY_SOURCE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACTIVITIES",
    "columnToEvaluate": "ACTIVITY_CODE",
    "componentId": "ACTIVITY_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and activity_type_code = 'NATIVE_PLSQL' and activity_code_language = 'PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Activity** in the Workflow Rendering tree **Activities** List, and edit its **PL/SQL Code** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activity Email Attachment SQL SQLi",
    "ruleKey": "WORKFLOW_ACTIVITY_EMAIL_ATTACHMENT_SQL_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACTIVITIES",
    "columnToEvaluate": "ATTRIBUTE_09",
    "componentId": "ACTIVITY_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and activity_type_code = 'NATIVE_SEND_EMAIL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Activity** of type **Send E-Mail** in the Workflow Rendering tree **Activities** List, and edit its **Attachment SQL** in the **Settings** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activity Variable SQLi",
    "ruleKey": "WORKFLOW_ACTIVITY_VARIABLE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY_VARIABLE",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACT_VARS",
    "columnToEvaluate": "VALUE",
    "componentId": "VARIABLE_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:LABEL",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Variable** in the Workflow Rendering tree **Activity Variables** List, and edit its **SQL Query** in the **Value** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Participants Value SQLi",
    "ruleKey": "WORKFLOW_PARTICIPANTS_VALUE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_PARTICIPANT",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_PARTICIPANT",
    "columnToEvaluate": "VALUE",
    "componentId": "PARTICIPANT_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:PARTICIPANT_TYPE",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Variables Value SQLi",
    "ruleKey": "WORKFLOW_VARIABLES_VALUE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_VARIABLE",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_VARIABLES",
    "columnToEvaluate": "VALUE",
    "componentId": "VARIABLE_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:LABEL",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value is not null",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Version Additional Data SQLi",
    "ruleKey": "WORKFLOW_VERSION_ADDITIONAL_DATA_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.1,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_VERSION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_VERSIONS",
    "columnToEvaluate": "QUERY_SOURCE",
    "componentId": "WORKFLOW_VERSION",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and query_type_code = 'SQL'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Allow Duplicate Submissions",
    "ruleKey": "ALLOW_DUPLICATE_SUBMISSIONS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "aeadm/managing-workspace-and-change-requests.html#GUID-782488EB-8DC0-4D04-974E-800E78369BC5",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "ALLOW_DUPLICATE_SUBMISSIONS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "The **Allow Duplicate Page Submissions** attribute determines whether or not a page can be submitted more than once. \n\nFor example, if this option is enabled, a user can click Submit multiple times, and potentially insert multiple records into the database. Users who use the back button and then try to resubmit a transaction would also be allowed to do so when this attribute is enabled. This would also be the case for a user who accidentally double-clicks a button.\n\nThe recommended setting for this option should be considered on a page-by-page basis, as it will vary based on the function of the page. For pages that insert data into the database or call a procedure, it should be set to `No`. For pages that allow users to filter data, it should be set to `Yes`.\n\nIf this attribute is set to `No`, you can also provide a URL where users will be redirected to, in the case of a duplicate page submission.",
    "fix": "To modify the **Allow Duplicate Page Submissions** attribute:\n\n1.  Edit the page that you want to associate an authorization scheme with.\n2.  Edit the page attributes for the page in question by clicking on it's name in the _Page Rendering_ tree.\n3.  In the Advanced section, set the **Enable duplicate page submissions** attribute to the appropriate value, based on the type of page. For example, it should be set to **No** for DML forms and **Yes** for most other types of pages.\n4.  If setting it to **No**, then optionally supply a URL to redirect users to in the case of a duplicate page submission.\n5.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Low",
    "ruleSeverityKey": "LOW",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Authorization Scheme",
    "ruleKey": "APPLICATION_AUTHORIZATION_SCHEME",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-9DFB08E7-0CA4-4C00-B05F-A0678FAAD326",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "Like most components in APEX, an Application can have an **Authorization Scheme**. By associating the **Authorization Scheme** with the application, only those users who are members of the corresponding **Authorization Scheme** will be able to access the application.\n\nThis technique is critical when using a central Authentication Scheme, such as LDAP. Without an application-level Authorization Scheme, then any user in the LDAP directory will be able to access the application. Thus, it's a best practice to create a group - either in LDAP or via database tables - and add authorized users to that group. The application Authorization Scheme can then check to see if a user is a member of the associated group or not, thus either allowing them or preventing them from using the application.",
    "fix": "  To associate an **Authorization Scheme** with an application:\n\n1.  Edit your application's **Shared Components**.\n2.  In the _Security_ region, click on **Security Attributes**.\n3.  In the _Authorization_ region, set the value of _Authorization Scheme_ to the corresponding **Authorization Scheme**.\n4.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Computation SQLi",
    "ruleKey": "APPLICATION_COMPUTATION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "APP_COMPUTATION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_COMPUTATIONS",
    "columnToEvaluate": "COMPUTATION",
    "componentId": "APPLICATION_COMPUTATION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "COMPUTATION_TYPE:COMPUTATION_ITEM",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Application Computation** definition in question, and edit its **Computation** code in the **Computation** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Items Escaped",
    "ruleKey": "APPLICATION_ITEMS_ESCAPED",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APP_ITEM",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_ITEMS",
    "columnToEvaluate": "ESCAPE_ON_HTTP_OUTPUT",
    "componentId": "APPLICATION_ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "ITEM_NAME",
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Application Items at Risk** are Application Items that have their **Escape Special Characters** attribute set to **No**. \n\nWhen set to **Yes**, any HTML rendered on the page will be properly escaped. When set to **No**, any HTML will be rendered as-is, introducing the risk of malicious code getting executed. \n\nThus, it is recommended to set this **Enable Special Characters** to **Yes**.",
    "fix": "To change the **Escape Special Characters** attribute for an **Application Item**:\n\n1.  Edit your application's **Shared Components**.\n2.  In the Application Logic region, click **Application Items**.\n3.  Click the application item you wish to modify.\n4.  In the Security region, set the **Escape Special Characters** attribute to  **Yes**\n5.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Items Session State",
    "ruleKey": "APPLICATION_ITEMS_SESSION_STATE",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-D3ECB171-681E-4452-BB33-5E74EC0EE13E",
    "builderUrlKey": "APP_ITEM",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_ITEMS",
    "columnToEvaluate": "SESSION_STATE_PROTECTION",
    "componentId": "APPLICATION_ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "ITEM_NAME",
    "operand": "DOES_NOT_EQUAL",
    "valChar": "N",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Application Items at Risk** are Application Items that have their Session State Protection attribute set to **Unrestricted**. \n\nThese application items can be altered by a malicious user via the URL of a page that does not have session state protection enabled, thus potentially changing application functionality.\n\nThere are two different settings:\n\n*   **Unrestricted**  \n    Item can be set via the URL or within APEX  \n*   **Restricted - May not be set from browser**  \n    Item can not be set via the URL under any circumstances - even if Session State Protection is disabled at the application level.",
    "fix": "To change the **Session State Protection** attribute for an **Application Item**:\n\n1.  Edit your application's **Shared Components**.\n2.  In the Application Logic region, click **Application Items**.\n3.  Click the application item you wish to modify.\n4.  In the Security region, set the Session State Protection attribute to any value other than **Unrestricted**.\n5.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Process SQLi",
    "ruleKey": "APPLICATION_PROCESS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "APP_PROCESS",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PROCESSES",
    "columnToEvaluate": "PROCESS",
    "componentId": "APPLICATION_PROCESS_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "PROCESS_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and process is not null\nand process_type_code = 'PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Application Process** definition in question, and edit its **Code** in the **Source** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Application Rejoin Sessions",
    "ruleKey": "APPLICATION_REJOIN_SESSIONS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "REJOIN_EXISTING_SESSIONS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Disabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Rejoin Sessions** attribute will allow users to rejoin a previously established session without providing a Session ID. APEX will only use the existing cookie to determine whether or not to consider the current session as valid.\n\nEnabling this option does present a security risk, as it would be easier for a hacker to take over an existing APEX session. Thus, this option should be set to Disabled.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session Management** area, locate **Rejoin Sessions** attribute and change its value to Disabled.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Authorization Scheme SQLi",
    "ruleKey": "AUTHORIZATION_SCHEME_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "AUTHORIZATION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_AUTHORIZATION",
    "columnToEvaluate": "ATTRIBUTE_01",
    "componentId": "AUTHORIZATION_SCHEME_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "AUTHORIZATION_SCHEME_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and scheme_type_code in \n  (\n   'NATIVE_EXISTS'\n  ,'NATIVE_FUNCTION_BODY'\n  ,'NATIVE_NOT_EXISTS'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Authorization Scheme** definition in question, and edit its **SQL Query** code in the **Authorization Scheme** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Avatar SQLi",
    "ruleKey": "AVATAR_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$AVATAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Avatar Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Avatar WHERE Clause SQLi",
    "ruleKey": "AVATAR_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$AVATAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Avatar Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Badge SQLi",
    "ruleKey": "BADGE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$BADGE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Badge Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Badge WHERE Clause SQLi",
    "ruleKey": "BADGE_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$BADGE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Badge Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Branch SQLi",
    "ruleKey": "BRANCH_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "BRANCH",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_BRANCHES",
    "columnToEvaluate": "BRANCH_ACTION",
    "componentId": "BRANCH_ID",
    "componentName": "BRANCH_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and (branch_language = 'PLSQL' or branch_type = 'Branch to PL/SQL Procedure')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Branch** in the Page Rendering tree **Branches** List, and edit its **PL/SQL Function Body** in the **Behavior** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Breadcrumb AuthZ Inconsistency",
    "ruleKey": "BREADCRUMB_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "BREADCRUMB",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with b as\n(\nselect\n   be.application_id\n  ,b.breadcrumb_name\n  ,be.entry_label\n  ,be.url\n  ,REGEXP_SUBSTR(be.url, '[^:]+', 1, 2) as target_page_id\n  ,be.authorization_scheme\n  ,be.authorization_scheme_id\n  ,b.breadcrumb_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(be.url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(be.url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(be.url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(be.url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n  apex_application_bc_entries be\n  ,apex_application_breadcrumbs b\nwhere\n  b.breadcrumb_id = be.breadcrumb_id\n  and be.url is not null\n  and be.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,b.application_id as application_id\n  ,null as page_id \n  ,breadcrumb_id as component_id \n  ,b.entry_label as component_name\n  ,null as column_name \n  ,null as item_name\n  ,b.breadcrumb_name as shared_comp_name\n  ,'Entry Label: ' || nvl(b.authorization_scheme,'None') || ' / Page: ' || nvl(b.target_authorization_scheme,'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(b.target_authorization_scheme_id,0) = nvl(b.authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n    end as result\nfrom b\nwhere 1=1\n  and b.application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **Breadcrumbs** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Browser Cache",
    "ruleKey": "BROWSER_CACHE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with a as (select browser_cache from apex_applications where application_id = #APP_ID#)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id\n  ,p.application_id as application_id\n  ,p.page_id page_id\n  ,null as component_id\n  ,null as component_name\n  ,null as column_name\n  ,null as item_name\n  ,null as shared_comp_name\n  ,p.browser_cache || ' (page) / ' || a.browser_cache \n     || ' (app)' as current_value\n  ,'Disabled' as valid_values\n  , case when \n      (case when p.browser_cache = 'Application Default' then a.browser_cache else p.browser_cache end) = 'Disabled' then '{ \"result\":\"PASS\"}' else '{ \"result\":\"FAIL\"}' end as result\nfrom\n  apex_application_pages p\n  ,a\nwhere\n  page_id > 0",
    "info": "**Browser Cache** dictates how the user's browser will store a rendered APEX Page in the browser's cache. Normally, browsers save the contents of an application's pages, however if the cache is disabled, the browser will not save the information and will be forced to reload the information from the server.\n\nFrom a security standpoint, Browser Cache should be disabled so that no sensitive information will not be kept at the browser level. Setting this to **Disabled** will also help prevent subtle back button issues.\n\nNOTE: When Browser Cache is set to **DIsabled**, APEX will include the HTTP Header directive cache-control: no-store indicating the browser should not store page content in either memory or disk. This feature will only work with browsers which support the cache-control directive",
    "fix": "To alter the value of **Browser Cache** for a specific page:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, alter the value for the **Browser Cache** select list.\n3.  Click **Save**.Browser Cache has three possible settings:\n    1.  **Application Default** - This will take its value from the current application's Browser Cache attribute.\n    2.  **Enabled** - Allows the browser to cache information from the page\n    3.  **Disabled** - Prohibits the browser from caching information for the specific page.\n\nThe page level `Browser Cache` setting, other than Application Default, will override what is defined at the Application level.\n\n**NOTE**: When **Browser Cache** is set to \"Disabled\", APEX will include the HTTP Header directive  **cache-control: no-store** indicating the browser should not store page content in either memory or disk. This feature will only work with browsers which support the _**cache-control**_ directive.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Build Status",
    "ruleKey": "BUILD_STATUS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-5D88B80F-1A82-474F-A6BC-C7787CC5703F",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "BUILD_STATUS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Run Only",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Button AuthZ Inconsistency",
    "ruleKey": "BUTTON_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/providing-security-through-authorization.html#GUID-8FBF5F46-0541-4859-8470-D10E333DD271",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with b as\n(\nselect\n   application_id\n  ,page_id\n  ,button_name\n  ,region_id\n  ,button_id\n  ,redirect_url\n  ,REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2) as target_page_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(redirect_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\n  ,authorization_scheme\n  ,authorization_scheme_id\nfrom\n  apex_application_page_buttons\nwhere\n  redirect_url is not null\n  and application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,b.application_id as application_id\n  ,b.page_id page_id \n  ,b.button_id as component_id \n  ,b.button_name as component_name\n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'Button: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n    ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n    end as result\nfrom b\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "The execution of a **Page Process**  can be linked to the click of a specific _button_ on the same page. When the **Authorization Scheme** of the Process and the Button do not match it might be possible for the user to have access to the Button and not the Process or vice versa.\n\nAPEX-SERT flags Page Processes where the execution is tied to a Button, but where the Button's Authorization scheme doesn't match the Authorization Scheme for the Process.",
    "fix": "Check the **Authorization Schemes** on both the driving **Button** and the **Page Process** for compatibility. Although they are not required to be the same, developers need to make sure that the Authorization Schemes are compatible and will provide the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cache",
    "ruleKey": "CACHE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-8DEEFEE2-0BB6-4882-BC84-8549A6497248",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "BROWSER_CACHE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Disabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Browser Cache** dictates how the user's browser will store a rendered APEX Page in the browser's cache. Normally, browsers save the contents of an application's pages, however if the cache is disabled, the browser will not save the information and will be forced to reload the information from the server.\n\nFrom a security standpoint, **Browser Cache** should be disabled so that no sensitive information will not be kept at the browser level. Setting this to **Disabled** will also help prevent subtle back button issues.\n\nNOTE: When Browser Cache is set to **Disabled**, APEX will include the HTTP Header directive cache-control: no-store indicating the browser should not store page content in either memory or disk. This feature will only work with browsers which support the cache-control directive",
    "fix": "Navigate to your Application Definition, and select **Security** tab.\n\nIn **Browser Security** area, locate **Cache** attribute and change its value to Disabled.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Calendar SQLi",
    "ruleKey": "CALENDAR_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_CSS_CALENDAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Calendar Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Calendar WHERE Clause SQLi",
    "ruleKey": "CALENDAR_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_CSS_CALENDAR'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Calendar Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cards SQLi",
    "ruleKey": "CARDS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_CARDS'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Cards Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cards WHERE Clause SQLi",
    "ruleKey": "CARDS_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_CARDS'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Cards Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Card Action AuthZ Inconsistency",
    "ruleKey": "CARD_ACTION_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\r\n(\r\nselect\r\n ic.application_id\r\n ,ic.page_id\r\n ,REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) as target_page_id\r\n ,ic.region_name\r\n ,ic.region_id\r\n ,ic.action_id as component_id\r\n ,nvl(label, action_type) column_alias \r\n ,coalesce(ic.authorization_scheme, \r\n   r.authorization_scheme, \r\n   pg.authorization_scheme) derived_authorization_scheme\r\n ,coalesce(ic.authorization_scheme_id, \r\n   r.authorization_scheme_id, \r\n   pg.authorization_scheme_id) derived_authorization_scheme_id\r\n  ,(select authorization_scheme\r\n    from apex_application_pages \r\n    where to_char(page_id) = REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) \r\n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \r\n    and application_id = #APP_ID#\r\n   ) target_authorization_scheme\r\n  ,(select authorization_scheme_id\r\n    from apex_application_pages \r\n     where to_char(page_id) = REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) \r\n     and REGEXP_LIKE(REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \r\n     and application_id = #APP_ID#\r\n   ) target_authorization_scheme_id\r\nfrom\r\n   apex_appl_page_card_actions ic\r\n  ,apex_application_page_regions r\r\n  ,apex_application_pages pg\r\nwhere  1=1\r\n  and ic.region_id = r.region_id \r\n  and ic.link_target is not null\r\n  and pg.page_id = ic.page_id\r\n  and pg.application_id = #APP_ID#\r\n  and ic.application_id = #APP_ID#\r\n)\r\nselect #EVAL_ID# as eval_id\r\n  ,#RULE_ID# as rule_id \r\n  ,c.application_id as application_id\r\n  ,c.page_id as page_id \r\n  ,c.component_id component_id \r\n  ,c.column_alias as component_name\r\n  ,null as column_name \r\n  ,null as item_name\r\n  ,null as shared_comp_name\r\n  ,'Action: ' || coalesce(c.derived_authorization_scheme,'None') || ' / Page: ' || nvl(c.target_authorization_scheme,'None') as current_value\r\n  ,'AuthZ Schemes Match' as valid_values\r\n,case \r\n  when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\r\n  when nvl(target_authorization_scheme_id,'0') = coalesce(c.derived_authorization_scheme_id,'0') then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' \r\n  else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' end as result\r\nfrom c",
    "info": "The execution of **Page Processes** can be linked to the click of a specific Button on the same page. When the **Authorization Schemes** of the Process and the Button do not match it might be possible for the user to have access to the Button and not the Process or vice versa.\r\n\r\nAPEX-SERT flags Page Processes where the execution is tied to a Button, but where the Button's Authorization scheme doesn't match the Authorization Scheme for the Process.",
    "fix": "Check the **Authorization Schemes** on both the **Card Action** and the **linked Page**  for compatibility. Although they are not required to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.\r\n\r\nWhen a Card action uses a column substitution for the Action, it cannot be confirmed by APEX-SERT and will require an exception",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart Series SQLi",
    "ruleKey": "CHART_SERIES_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "JET_CHART_SERIES",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_CHART_S",
    "columnToEvaluate": "DATA_SOURCE",
    "componentId": "SERIES_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and data_source is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region Series** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart Series WHERE Clause SQLi",
    "ruleKey": "CHART_SERIES_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_CHART_S",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region Series** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart SQLi",
    "ruleKey": "CHART_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_JET_CHART'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Chart WHERE Clause SQLi",
    "ruleKey": "CHART_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_JET_CHART'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Charts Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report Column AuthZ Inconsistency",
    "ruleKey": "CLASSIC_REPORT_COLUMN_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2) as target_page_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link_url, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\n  ,ic.region_name\n  ,ic.region_id\n  ,ic.column_alias\n  ,ic.authorization_scheme\n  ,ic.authorization_scheme_id\nfrom\n   apex_application_page_rpt_cols ic\n  ,apex_application_page_regions r\nwhere 1=1\n  and ic.region_id = r.region_id \n  and ic.column_link_url is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,c.column_alias as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'Report Column: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report Column Escaped",
    "ruleKey": "CLASSIC_REPORT_COLUMN_ESCAPED",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_RPT_COLS",
    "columnToEvaluate": "DISPLAY_AS_CODE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": "COLUMN_ALIAS",
    "itemName": null,
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "WITHOUT_MODIFICATION",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Classic Report** columns can render HTML as part of their item. In this case, it is important to ensure that the HTML rendered is properly escaped, so that in the case the HTML contains malicious code, it is rendered harmless.\n\n**Classic Report** columns contain a property called **Escape Special Characters**. When set to **Yes**, any HTML rendered on the page will be properly escaped. When set to **No**, any HTML will be rendered as-is, introducing the risk of malicious code getting executed. Thus, it is recommended to set this **Enable Special Characters** to **Yes**.",
    "fix": "To change the **Escape Special Characters** attribute for a **Classic Report** column:\n\n1.  Edit the corresponding page of your application that contains the report in question.\n2.  Expand the Report in the Rendering panel, click on the Tree View toggle next to the affected report.\n3.  Select the column in question.\n4.  In the Column Attribute panel/region, locate the **Security section**, and toggle the switch **Escape Special Characters** attribute to **Yes**.\n5.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report SQLi",
    "ruleKey": "CLASSIC_REPORT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code in ('SQL_QUERY','FUNCTION_RETURNING_SQL_QUERY')\nand source_type_plugin_name = 'NATIVE_SQL_REPORT'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Classic Report Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Classic Report WHERE Clause SQLi",
    "ruleKey": "CLASSIC_REPORT_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'SQL_QUERY'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Classic Report Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Cleanup PL/SQL Code",
    "ruleKey": "CLEANUP_PLSQL_CODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-F2324900-0AD3-4C0A-8B86-AE4B9C25F991",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "DB_SESSION_CLEANUP_CODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Cleanup PL/SQL Code** is typically used to set the security context of an application. The PL/SQL placed here will execute after everything else on each and every page within your application.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Database Session** area, examine **Cleanup PL/SQL Code** attribute for reported SQL Injections issues. In particular, check usage of DBMS\\_SQL, EXECUTE\\_IMMEDIATE and incorrect item substitution syntax.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Column Toggle SQLi",
    "ruleKey": "COLUMN_TOGGLE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_JQM_COLUMN_TOGGLE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Column Toggle Report Region** in the Page Rendering tree, and edit its **SQL Query** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Column Toggle WHERE Clause SQLi",
    "ruleKey": "COLUMN_TOGGLE_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_JQM_COLUMN_TOGGLE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Column Toggle Report Region** in the Page Rendering tree, and edit its **Where Clause** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Comments SQLi",
    "ruleKey": "COMMENTS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$COMMENTS'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Comments WHERE Clause SQLi",
    "ruleKey": "COMMENTS_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$COMMENTS'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Compatibility Mode",
    "ruleKey": "COMPATIBILITY_MODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A06-2021",
    "riskName": "Vulnerable and Outdated Components",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/upgrading-apex-applications.html#GUID-3415C581-1146-4D64-8044-DE5BD67F186C",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "COMPATIBILITY_MODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "21.2",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Compatibility Mode** attribute controls the backward compatibility of the APEX runtime engine when executing an application. Certain runtime behaviors change from release to release. To not break or change the behavior of existing applications, this attribute is automatically set during upgrade if necessary.",
    "fix": "Navigate to your Application Definition, and select **Definition** tab.  \nIn **Properties** area, locate **Compatibility Mode** attribute and change its value to the desired setting.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Content Row SQLi",
    "ruleKey": "CONTENT_ROW_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$CONTENT_ROW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Content Row WHERE Clause SQLi",
    "ruleKey": "CONTENT_ROW_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$CONTENT_ROW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Debug Mode",
    "ruleKey": "DEBUG_MODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-583B8D2A-D236-4A35-A510-F87BF3C694FA",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "DEBUGGING",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Not Allowed",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Debugging** attribute determines whether or not your application can be run in Debug mode. If enabled, then anyone with knowledge of how APEX works - including end users - can run your application with Debug enabled. This will produce a thorough report of your application logic, code and attributes. Although in APEX 4 and above, debug information is no longer emitted to the page, running an application with Debug enables can hinder performance and potentially show components who's visibility is linked to the Debug setting.\n\nIt is critical that this value be disabled for production applications, as the information provided by debug mode could potentially be used by a hacker to compromise your application.\n\nThis setting should always be set to No, since in APEX 4.2 and above, if you are logged in as a developer and are also running an application, **Debug Mode** will be automatically enabled.",
    "fix": "Navigate to your **Application** Definition, and select **Definition** tab.  \nIn Properties area, locate **Debugging** attribute and set its value to **No**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Dynamic Action SQLi",
    "ruleKey": "DYNAMIC_ACTION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_DA_ACTS",
    "columnToEvaluate": "ATTRIBUTE_01",
    "componentId": "DYNAMIC_ACTION_ID",
    "componentName": "DYNAMIC_ACTION_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and action_code = 'NATIVE_EXECUTE_PLSQL_CODE'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Dynamic Action** in the Page Rendering tree, and edit its **PL/SQL Code** in the **Settings** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Dynamic Content Contains Binds",
    "ruleKey": "DYNAMIC_CONTENT_CONTAINS_BINDS",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/cross-site-scripting-protection.html#GUID-3E24746E-378C-478E-85F6-55DD8EC4A367",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "select\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id\n  ,r.application_id as application_id\n  ,r.page_id page_id\n  ,r.region_id as component_id\n  ,null as component_name\n  ,null as column_name\n  ,null as item_name\n  ,null as shared_comp_name\n  ,r.region_source as current_value\n  ,'Returning bind variables should be escaped' as valid_values\n  ,case\n    when REGEXP_COUNT(replace(region_source, ':=', null), ':\\S*\\s', 1, 'i') > 0\n    then\n      '{ \"result\":\"FAIL\"}' else '{ \"result\":\"PASS\"}'\n    end as result\nfrom\n  apex_application_page_regions r\nwhere\n  page_id > 0\n  and source_type_code = 'NATIVE_DYNAMIC_CONTENT'",
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Dynamic Content SQLi",
    "ruleKey": "DYNAMIC_CONTENT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_DYNAMIC_CONTENT'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Embed in Frames",
    "ruleKey": "EMBED_IN_FRAMES",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-8DEEFEE2-0BB6-4882-BC84-8549A6497248",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "BROWSER_FRAME",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Deny:Allow from same origin",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Embed in Frames** dictates whether a browser is allowed to display your application pages within an HTML frame, and if so under what circumstances.\n\nApplications that allow frame embedding are potentially at risk of \"clickjacking\" atacks. This is where an attacker uses multiple page layers to intercept clicks that were meant for buttons or links in the application, instead routing them to another page.\n\nOptions are:\n\n*   **Deny** - The page is not allowed to be rendered within a frame, regardless of the site attempting to do so.\n*   **Allow** - The page can be displayed in any frame, regardless of origin.\n*   **Allow from same origin** - The page can be displayed within a frame, but only if the frame is from the same origin as the page.\n\nNOTE: This feature requires modern browsers that support the HTTP header response variable _X-Frame-Options_.",
    "fix": "Navigate to your **Application** Definition, and select **Security** tab.  \nIn **Browser Security** area, locate **Embed in Frames** attribute and set its value to either **Deny** or **Allow from same origin**.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Error Handling Function",
    "ruleKey": "ERROR_HANDLING_FUNCTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-B744BE26-69B6-4084-A217-114CF05A5A4B",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "ERROR_HANDLING_FUNCTION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The Error Handling Function is a function that will be called when an error is raised from an APEX application. This function can be set to handle specific errors, suppress sensitive information from error messages, and even send notifications when errors occur. This application can be set at the application and page lever, where a page-level setting will override an application-level one.\n\nWhile APEX will work just fine without one, it is strongly recommended that a custom function be deployed and deployed with all applications. The Sample Database Application contains a sample error handling function that can be expanded upon.\n\nThe ErrorHandling Functions must adhere to the following signature:\n\n`function [function name]`   \n `(`  \n  `p_error in apex_error.t_error`  \n `)`  \n`return apex_error.t_error_result;`\n\nSee the Oracle APEX API Reference for more details on how to create an Error Handling Function.",
    "fix": "Navigate to your Application Definition, and select **Definition** tab.  \nIn **Error Handling** area, locate **Error Handling Function** attribute and set its value to not NULL, for example to your PL/SQL error function name.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Facet SQLi",
    "ruleKey": "FACET_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_PAGE_FILTERS",
    "columnToEvaluate": "LOV_DEFINITION",
    "componentId": "REGION_ID",
    "componentName": "ITEM_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and suggestions_type_code = 'DYNAMIC'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Form Autocomplete",
    "ruleKey": "FORM_AUTOCOMPLETE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/identifying-at-risk-passwords.html#GUID-9B68C8BE-83FD-4057-B098-11ADB6B1411B",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "FORM_AUTOCOMPLETE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Off",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "By default, all APEX pages have their **Form Auto Complete** attribute set to enabled. This makes using applications a lot more efficient, as most browsers will remember previous data entered and automatically present those values to users. However, if the data entered is of a sensitive nature - such as credit card, SSN or account numbers - that data will be stored on the client's local browser.\n\nWhile the data stored locallymay be encrypted, it is not password-protected. For example: you enter a credit card number and submit the form. The next time you run that page, the browser will automatically remember which values you previously used. Thus, you will be able to see a list of all previous credit card numbers entered.\n\n**Form Auto Complete** should only be enabled on pages where there is no concern about the data being entered there. For all other pages, **Form Auto Complete** should be disabled.",
    "fix": "To disable **Form Auto Complete**:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region set the value of Form Auto Complete to **Off**.\n3.  Click **Save.**",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Hidden Item Value Protected",
    "ruleKey": "HIDDEN_ITEM_VALUE_PROTECTED",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/about-item-types.html#GUID-8CAA1BA5-DCA8-4DF0-A841-3DC40E67CA9C",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ATTRIBUTES",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "HIDDEN_ITEM_VALUE_PROTECTED",
    "additionalWhere": "and display_as_code = 'NATIVE_HIDDEN'",
    "customQuery": null,
    "info": "Despite its name, a **Hidden Item** will still have its definition and value rendered in the underlying HTML of a page. This allows for a malicious user to both view and edit the value and submit it back to APEX for processing, allowing for the update of unintended records.\r\n\r\nFortunately, Hidden Items in APEX contain an attribute called Value Protected. When enabled, if the value of a Hidden Item has been manipulated at all, APEX will reject the page submission and generate an error.\r\n\r\nThe Value Protected attribute is set to Yes by default, and should be left that way. The only exception to this is when the value of Hidden Item needs to be altered by either JavaScript or a Dynamic Action. If that is the case, and Value Protected is set to No, then additional validations should be made to ensure that the value set was a valid one, not a malicious one.",
    "fix": "To ensure that a **Hidden Item** is protected:\r\n\r\n1.  Edit a Hidden page item.\r\n2.  In the Settings region, set the value of Value Protected to **Yes**.\r\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "HTML Escaping Mode",
    "ruleKey": "HTML_ESCAPING_MODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "HTML_ESCAPING_MODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Extended",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "Traditionally, APEX has depended on the htf.escape\\_sc function to escape HTML before rendering in certain places. While this approach does work, it is somewhat limited in scope as to what gets escaped, as it will only escape the following characters:\n\n*   &\n*   \"\n*   \\<\n*   \\>\n\n   \nWhen set to **Basic**, the **HTML Escaping Mode** will function as if it were calling htf.escape\\_sc, and only escape the four characters listed above. Setting it to Extended mode will escape all characters in Basic mode as well as the following characters:\n\n*   &\n*   \"\n*   \\<\n*   \\>\n*   '\n*   /\n*   Non-ASCII characters\n\nAdditionally, **Extended** mode will also escape non-ASCII characters if the database character set is not set to AL32UTF8. By default, existing applications will have this value set to Basic, and new applications will have it set to Extended. It is recommended to set it to Extended, but only after thorough testing is conducted and functionality is not broken because of the change.\n\nNote: This feature is only available when the Compatibility Mode attribute is set to 4.1 or greater.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Browser Security** area, locate **HTML Escaping Mode** attribute and set its value to Extended.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "HTTP Response Headers",
    "ruleKey": "HTTP_RESPONSE_HEADERS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "HTTP_RESPONSE_HEADERS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **HTTP Response Headers** attribute allows a developer to supplement what APEX sends to the browser as part of the response header. This is a more advanced feature of APEX, and is unlikely to be used in most applications.",
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Include jQuery Migrate",
    "ruleKey": "INCLUDE_JQUERY_MIGRATE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A06-2021",
    "riskName": "Vulnerable and Outdated Components",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-user-interface-attributes.html#GUID-B2B87317-8178-4C82-A4B4-831132EB8A9F",
    "builderUrlKey": "APPLICATION_USER_INTERFACE",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_USER_INTERFACES",
    "columnToEvaluate": "INCLUDE_JQUERY_MIGRATE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This setting specifies if the **jQuery Migrate** plug-in should be included on every page in the application.\n\nThe plug-in restores deprecated features and behaviors of jQuery so that old JavaScript code and jQuery plug-ins will still run properly with the jQuery version loaded by Oracle APEX.\n\nIf you are confident your application and any used jQuery plug-in does not contain any references to deprecated jQuery features, set this to **Off** to reduce the overall size of the JavaScript files loaded.",
    "fix": "Navigate to your Application Definition, and select **User Interface tab**.\n\nIn **Javascript** area, locate **Include jQuery Migrate** attribute and use the slider to set its value to **Off**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Include Legacy Javascript",
    "ruleKey": "INCLUDE_LEGACY_JAVASCRIPT",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A06-2021",
    "riskName": "Vulnerable and Outdated Components",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-user-interface-attributes.html#GUID-B2B87317-8178-4C82-A4B4-831132EB8A9F",
    "builderUrlKey": "APPLICATION_USER_INTERFACE",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_USER_INTERFACES",
    "columnToEvaluate": "INCLUDE_LEGACY_JAVASCRIPT",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This setting specifies if deprecated or desupported **JavaScript** functions are included on every page in the application. \n\nThe functions deprecated or desupported are listed in the Release Notes for every release. \n\nIf you are confident your application does not contain any references to those deprecated or desupported functions, **don't check any checkbox** to reduce the overall size of the JavaScript files loaded.",
    "fix": "Navigate to your Application Definition, and select **User Interface tab**.\n\nIn **Javascript** area, locate **Include Deprecated or Desupported Javascript Functions** attribute and set both Pre 18.1 and 18.x  checkbox values to **Off**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Initialization PL/SQL Code",
    "ruleKey": "INITIALIZATION_PLSQL_CODE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-F2324900-0AD3-4C0A-8B86-AE4B9C25F991",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "DB_SESSION_INIT_CODE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Initialization PL/SQL Code** is typically used to set the security context of an application. The PL/SQL placed here will execute before anything else on each and every page within your application.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Database Session** area, examine **Initialization PL/SQL Code** attribute for reported SQL Injections issues. In particular, check usage of DBMS\\_SQL, EXECUTE\\_IMMEDIATE and incorrect item substitution syntax.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Grid Column AuthZ Inconsistency",
    "ruleKey": "INTERACTIVE_GRID_COLUMN_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) as target_page_id\n  ,ic.region_name\n  ,ic.region_id\n  ,ic.name as column_alias\n  ,ic.authorization_scheme\n  ,ic.authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_appl_page_ig_columns ic\nwhere 1=1\n  and ic.item_type = 'NATIVE_LINK'\n  and ic.link_target is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,c.column_alias as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'IG Column: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\n\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "APEX-SERT flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the Page. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Grid SQLi",
    "ruleKey": "INTERACTIVE_GRID_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_IG'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Grid WHERE Clause SQLi",
    "ruleKey": "INTERACTIVE_GRID_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_IG'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Column AuthZ Inconsistency",
    "ruleKey": "INTERACTIVE_REPORT_COLUMN_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/providing-security-through-authorization.html#GUID-8FBF5F46-0541-4859-8470-D10E333DD271",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2) as target_page_id\n  ,ic.region_name\n  ,ic.region_id\n  ,ic.column_alias\n  ,coalesce( ic.authorization_scheme,r.authorization_scheme) as authorization_scheme\n  ,coalesce( ic.authorization_scheme_id, r.authorization_scheme_id) as authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(ic.column_link, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_application_page_ir_col ic\n  ,apex_application_page_regions r\nwhere 1=1\n  and ic.region_id = r.region_id \n  and ic.column_link is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,c.column_alias as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'IR Column: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Column Escaped",
    "ruleKey": "INTERACTIVE_REPORT_COLUMN_ESCAPED",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_IR_COL",
    "columnToEvaluate": "DISPLAY_TEXT_AS",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": "COLUMN_ALIAS",
    "itemName": null,
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "WITHOUT_MODIFICATION",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "**Interactive Report** columns can render HTML as part of their item. In this case, it is important to ensure that the HTML rendered is properly escaped, so that in the case the HTML contains malicious code, it is rendered harmless.\n\n**Interactive Report** columns contain a property called **Escape Special Characters**. When set to **Yes**, any HTML rendered on the page will be properly escaped. When set to **No**, any HTML will be rendered as-is, introducing the risk of malicious code getting executed. Thus, it is recommended to set this **Enable Special Characters** to **Yes**.",
    "fix": "To change the **Escape Special Characters** attribute for an **Interactive Report** column:\n\n1.  Edit the corresponding page of your application that contains the report in question.\n2.  Expand the Report in the Rendering panel, click on the Tree View toggle next to the affected report.\n3.  Select the column in question.\n4.  In the Column Attribute panel/region, locate the **Security section**, and toggle the switch **Escape Special Characters** attribute to **Yes**.\n5.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Link AuthZ Inconsistency",
    "ruleKey": "INTERACTIVE_REPORT_LINK_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   application_id\n  ,page_id\n  ,REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2) as target_page_id\n  ,region_name\n  ,region_id\n  ,detail_link_auth_scheme as authorization_scheme\n  ,detail_link_auth_scheme_id as authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(detail_link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_application_page_ir\nwhere 1=1\n  and detail_link_type = 'Custom Link target'\n  and application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,null as component_name\n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'IR Link: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\n\nfrom c\nwhere 1=1\n  and application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report Link Text &ITEM. Syntax",
    "ruleKey": "INTERACTIVE_REPORT_LINK_TEXT_ITEM_SYNTAX",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/cross-site-scripting-protection.html#GUID-DC111134-6369-4424-8DAD-BB9649F9B03F",
    "builderUrlKey": "REGION",
    "impact": "COLUMN",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_IR_COL",
    "columnToEvaluate": "COLUMN_LINKTEXT",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": "COLUMN_ALIAS",
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "XSS_ITEM_SYNTAX",
    "additionalWhere": null,
    "customQuery": null,
    "info": "Use of **&ITEM.** syntax can potentially leave an application open to **SQL Injection** attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the variables will be replaced verbatim with the variable value. For example, suppose there is a a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n**SELECT COUNT(\\*) FROM users WHERE username = '&USERNAME.' AND password = '&PASSWORD.'**\n\nIf the user were to enter this as their password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nThe resulting SQL would be:\n\n**SELECT COUNT(\\*) FROM users WHERE username = 'SCOTT' AND password = 'i\\_dont\\_know' OR 'x' = 'x'**\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.  \nBy using bind variables, this can be avoided.\n\n**SELECT COUNT(\\*) FROM users WHERE username = :USERNAME AND password = :PASSWORD**\n\nNow, if you enter this as your password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nUnless that is specifically your password, the database will return _**No Data Found**_.\n\nWhile it may not be optimal performance-wise, the following items can safely be used with the **&ITEM\\_NAME.** syntax, as they are all APEX built-in items and can not be changed by an end-user:\n\n*   **APP\\_ID**\n*   **APP\\_ALIAS**\n*   **APP\\_PAGE\\_ID**\n*   **APP\\_USER**\n*   **SESSION**\n*   **DEBUG**\n\n**APEX-SERT** will also ignore items that use the &ITEM\\_NAME. syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "To change the **Link Column** attribute for an **Interactive Report** column:\n\n1.  Edit the corresponding page of your application that contains the report in question.\n2.  Expand the Report in the Rendering panel, click on the Tree View toggle next to the affected report.\n3.  Select the column in question.\n4.  In the Column Attribute panel/region, locate the **Link section**\n5.  Ensure that the **&ITEM.** reference is to a page item or an application item, and that the value of that item is properly escaped (**Escape Special Characters** attribute to **Yes)**. Otherwise, remove any reference to that item.\n6.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report SQLi",
    "ruleKey": "INTERACTIVE_REPORT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'DYNAMIC_QUERY'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Interactive Report WHERE Clause SQLi",
    "ruleKey": "INTERACTIVE_REPORT_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'DYNAMIC_QUERY'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Item Default SQLi",
    "ruleKey": "ITEM_DEFAULT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ITEM_DEFAULT",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and item_default is not null\nand item_default_type in \n  (\n   'SQL_QUERY'\n  ,'SQL_QUERY_COLON'\n  ,'EXPRESSION'\n  ,'FUNCTION_BODY'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Item** in the Page Rendering tree, and edit its **PL/SQL Function Body** in the **Default** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Item Session State Protection Level",
    "ruleKey": "ITEM_SESSION_STATE_PROTECTION_LEVEL",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-D3ECB171-681E-4452-BB33-5E74EC0EE13E",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ITEM_PROTECTION_LEVEL",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "Unrestricted",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and display_as_code = 'NATIVE_HIDDEN'",
    "customQuery": null,
    "info": "This attribute identifies the total number ofItems that have their Session State Protection attribute set to Unrestricted for an application. These unrestricteditems can be manipulated via the URL by a malicious user, causing potentially disastrousresults.\n\nThere are four possible values for Session State Protection at the item level:\n\n*   **Unrestricted**  \n    The item may be set via the URL with no restrictions.\n*   **Restricted - may not be set from browser**  \n    The item can not be set via the URL. This value only applies to the following item types:  \n        - Display as Text (escape special characters, does not save state)  \n        - Display as Text (does not save state)  \n        - Display as Text (based on LOV, does not save state)  \n        - Display as Text (based on PLSQL, does not save state)  \n        - Text Field (Disabled, does not save state)  \n        - Stop and Start HTML Table (Displays label only)\n*   **Checksum Required - Application Level**  \n    The item can be set via the URL provided an application-level checksum is present in the URL.\n*   **Checksum Required - User Level**  \n    The item can be set via the URL provided a user-level checksum is present in the URL.\n*   **Checksum Required - Session Level**  \n    The item can be set via the URL provided a session-level checksum is present in the URL.\n\nIt is broken down by page in the summary report. To see which items Session State Protection is set to Unrestricted, click on the View link for the corresponding page.\n\nKeep in mind that Session State Protection must be enabled at the application level for this attribute to work properly.",
    "fix": "To change the **Session State Protection** attribute for a **Page Item**:\n\n1.  Edit a page item in your application that you wish to enable Session State Protection.\n2.  In the Security region, set the Session State Protection attribute to any value other than **Unrestricted**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Item Source SQLi",
    "ruleKey": "ITEM_SOURCE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ITEM_SOURCE",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and item_source is not null\nand item_source_type in \n  (\n   'SQL Query (return single value)'\n  ,'SQL Query (return colon separated value)'\n  ,'Expression'\n  ,'Function Body'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Item** in the Page Rendering tree, and edit its **PL/SQL Function Body** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Legacy Region Types",
    "ruleKey": "LEGACY_REGION_TYPES",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-app-legacy-components.html",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "SOURCE_TYPE_CODE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "DOES_NOT_EQUAL",
    "valChar": "CALENDAR:PLSQL_PROCEDURE:DATA_UPLOAD_COLUMN_MAPPING",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "Oracle still supports L**egacy** page **region types**, but does not recommend using them.",
    "fix": "To verify the **Legacy Page Region Type** attribute:\n\n1.  Edit the corresponding page of your application and navigate to the **region** in question.\n2.  In the Identification region, locate the **Type** attribute.\n3.  Ensure the **Legacy** region type is not used.\n4.  Save your page",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List Entry AuthZ Inconsistency",
    "ruleKey": "LIST_ENTRY_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "LIST",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   le.application_id\n  ,null as page_id\n  -- substr 5: after the 'f?p='\n  ,REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) as target_app_id\n  ,REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2) as target_page_id\n  ,le.list_name\n  ,le.entry_text\n  ,le.authorization_scheme\n  ,le.authorization_scheme_id\n  ,le.list_entry_id\n  ,(select app_page.authorization_scheme\n      from apex_applications app\n      join apex_application_pages app_page on (app.application_id = app_page.application_id)\n      where to_char(app_page.page_id) = REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2) \n      and REGEXP_LIKE(REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n      and (to_char(app.application_id) = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or app.alias = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or (REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) = '&APP_ID.' and to_char(app.application_id) = #APP_ID#)) \n    ) target_authorization_scheme\n    ,(select app_page.authorization_scheme_id\n      from apex_applications app\n      join apex_application_pages app_page on (app.application_id = app_page.application_id)\n      where to_char(app_page.page_id) = REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2) \n      and REGEXP_LIKE(REGEXP_SUBSTR(le.entry_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n      and (to_char(app.application_id) = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or app.alias = REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) or (REGEXP_SUBSTR(substr(le.entry_target,5), '[^:]+', 1, 1) = '&APP_ID.' and to_char(app.application_id) = #APP_ID#)) \n    ) target_authorization_scheme_id\nfrom\n   apex_application_list_entries le\nwhere 1=1\n  and le.entry_target is not null\n  and le.entry_target like 'f?p%'\n  and le.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,null as page_id \n  ,c.list_entry_id component_id \n  ,c.entry_text as component_name\n  ,null as column_name \n  ,null as item_name\n  ,list_name as shared_comp_name\n  ,'List Entry: ' || nvl(c.authorization_scheme,'None') || ' / Page: ' || nvl(c.target_authorization_scheme,'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n        when nvl(c.target_authorization_scheme_id,0) = nvl(c.authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n    end as result\nfrom c\nwhere 1=1\n  and c.application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **List Entries** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa.",
    "fix": "Check the **Authorization Schemes** on both the **List Entries** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List Entry Does Not Contain &ITEM. Syntax",
    "ruleKey": "LIST_ENTRY_DOES_NOT_CONTAIN_ITEM_SYNTAX",
    "categoryName": "Cross-Site Scripting",
    "categoryKey": "CROSS_SITE_SCRIPTING",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/creating-lists.html#GUID-0ABE095F-AE4D-438C-840E-3B47915E6109",
    "builderUrlKey": "LIST",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LIST_ENTRIES",
    "columnToEvaluate": "ENTRY_TEXT",
    "componentId": "LIST_ID",
    "componentName": "ENTRY_TEXT",
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "XSS_ITEM_SYNTAX",
    "additionalWhere": null,
    "customQuery": null,
    "info": "Use of **&ITEM.** syntax can potentially leave an application open to **SQL Injection** attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n**SELECT COUNT(\\*) FROM users WHERE username = '&USERNAME.' AND password = '&PASSWORD.'**\n\nIf the user were to enter this as their password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nThe resulting SQL would be:\n\n**SELECT COUNT(\\*) FROM users WHERE username = 'SCOTT' AND password = 'i\\_dont\\_know' OR 'x' = 'x'**\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.  \nBy using bind variables, this can be avoided.\n\n**SELECT COUNT(\\*) FROM users WHERE username = :USERNAME AND password = :PASSWORD**\n\nNow, if you enter this as your password:\n\n**i\\_dont\\_know' OR 'x' = 'x**\n\nUnless that is specifically your password, the database will return _**No Data Found**_.\n\nWhile it may not be optimal performance-wise, the following items can safely be used with the **&ITEM\\_NAME.** syntax, as they are all APEX built-in items and can not be changed by an end-user:\n\n*   **APP\\_ID**\n*   **APP\\_ALIAS**\n*   **APP\\_PAGE\\_ID**\n*   **APP\\_USER**\n*   **SESSION**\n*   **DEBUG**\n\n**APEX-SERT** will also ignore items that use the &ITEM\\_NAME. syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "To change the attributes for a **List Entry**:\n\n1.  Edit your application's **Shared Components**.\n2.  In the Shared Component region, click your List.\n3.  Click the List entry you wish to modify.\n4.  Examine each reference using the **&ITEM.** syntax. See below for details.\n5.  Click **Apply Changes**.\n\nExamine the code for uses of **&ITEM.** syntax and, wherever possible, replace the usage with:\n\n*   **:ITEM\\_NAME** bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   **v('ITEM\\_NAME')** syntax\n    *   in stored PL/SQL program units called from APEX\n*   **ITEM\\_NAME** syntax\n    *   in conditions\n*   **&ITEM\\_NAME.**\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the **&ITEM.** syntax is necessary, developers can mitigate much of the risk by using **HTF.ESCAPE\\_SC** to escape the referenced item.\n\n_**Caution**: Use of **&ITEM.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List of Values SQLi",
    "ruleKey": "LIST_OF_VALUES_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "LOV",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LOVS",
    "columnToEvaluate": "LIST_OF_VALUES_QUERY",
    "componentId": "LOV_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_OF_VALUES_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and source_type_code in ('FUNC_BODY_RETURNING_SQL','SQL')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **List of Values** definition in question, and edit its **SQL Query** code in the **Source** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List of Values WHERE Clause SQLi",
    "ruleKey": "LIST_OF_VALUES_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "LOV",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LOVS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "LOV_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_OF_VALUES_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **List of Values** definition in question, and edit its **Where Clause** code in the **Source** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "List SQLi",
    "ruleKey": "LIST_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "LIST",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_LISTS",
    "columnToEvaluate": "LIST_QUERY",
    "componentId": "LIST_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "LIST_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and list_query is not null\nand list_type_code = 'SQL_QUERY'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **List** definition in question, and edit its **Query** in the **List Query** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Logging",
    "ruleKey": "LOGGING",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-application-attributes.html#GUID-583B8D2A-D236-4A35-A510-F87BF3C694FA",
    "builderUrlKey": "APPLICATION_DEFINITION",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "LOGGING",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Logging** attribute determines whether or not APEXwill write information to two log tables:\n\n*   **APEX\\_WORKSPACE\\_ACCESS\\_LOG**  \n    This log records all access attempts - successful or otherwise - made to any APEXapplication. It includes the user name, date of attempt, IPAddress, among other details about each access attempt. When using a custom authentication scheme, you can augment this log with the APEX\\_UTIL.SET\\_AUTHENTICATION\\_RESULT and APEX\\_UTIL.SET\\_CUSTOM\\_AUTH\\_STATUS APIs.  \n    undefined\n*   **APEX\\_WORKSPACE\\_ACTIVITY\\_LOG**  \n    This log records all page views which occur within your workspace. It includes all pertinent details about each page view, including user name and session, timestamp, IP address, browser, and associated error messages.\n\nAPEX logs are purged roughly every two weeks by default. APEX will retain high-level information from its logs, but this is often times not detailed enough for most organizations. Thus, itis recommended that you configure a custom archival mechanism to preserve all data stored in the logs.",
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map Layer SQLi",
    "ruleKey": "MAP_LAYER_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_PAGE_MAP_LAYERS",
    "columnToEvaluate": "LAYER_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and layer_source is not null",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map Layer WHERE Clause SQLi",
    "ruleKey": "MAP_LAYER_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_PAGE_MAP_LAYERS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map SQLi",
    "ruleKey": "MAP_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_MAP_REGION'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Map WHERE Clause SQLi",
    "ruleKey": "MAP_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_MAP_REGION'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Maximum Row Count",
    "ruleKey": "MAXIMUM_ROW_COUNT",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/developing-reports.html#GUID-A63ECD33-D759-4725-9666-A02719FB35B8",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "select \n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,r.application_id as application_id\n  ,r.page_id page_id \n  ,r.region_id as component_id\n  ,null as component_name \n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,nvl(r.maximum_row_count, 500) as current_value\n  ,'Less or Equal to than 500' as valid_values\n  ,case \n     when nvl(r.maximum_row_count, 500) < 501 then '{\"result\":\"PASS\"}' \n     else '{\"result\":\"FAIL\"}' \n     end as result \nfrom\n  apex_application_page_rpt rpt\n ,apex_application_page_regions r \nwhere \n  rpt.region_id = r.region_id",
    "info": "The **Maximum Row Count** of a report dictates the maximum number of rows that will be retrieved from the database. A high Maximum Row Count could allow a user to access and export large amounts of data and walk away with it.\n\nDuring normal system use, most users will be working with the first few hundred rows of data in a report and will never navigate past the first few pages. It is an advantage, not only for security but also for performance reasons to keep the **Maximum Row Count** as low as possible.",
    "fix": "To set the **Maximum Row Count**:  \n**Classic Reports**\n\n1.  Select the Attributes node of the corresponding Classic Report.\n2.  In the Advanced region, set `Maximum Row Count` to the desired value.\n3.  Click **Save**.\n\n---\n\n**Interactive Reports:**\n\n1.  Select the Attributes node of the corresponding Interactive Report.\n2.  In the Advanced region, set the value of `Maximum Row Count` to the desired value.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Maximum Session Idle Time",
    "ruleKey": "MAXIMUM_SESSION_IDLE_TIME",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "MAXIMUM_SESSION_IDLE_SECONDS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "LESS_THAN",
    "valChar": null,
    "valNumber": 3601,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Maximum Session Idle** attribute determines how long - in seconds, not minutes - an APEX session can be idle before it is automatically timed out.\n\nIf this value is set to NULL, then APEX will not check for idle time, thus enabling a user to be idle for as long as the Maximum Session Length permits.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session Management** area, locate **Maximum Session Idle Time in Seconds** attribute and change its value to between 0 and 3600.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Maximum Session Length",
    "ruleKey": "MAXIMUM_SESSION_LENGTH",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-33A67D5E-1128-4D23-9C5C-15FC9BE1B783",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "MAXIMUM_SESSION_LIFE_SECONDS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "LESS_THAN",
    "valChar": null,
    "valNumber": 28801,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Maximum Session Length** attribute determines how long - in seconds, not minutes - an APEX session will be valid before it is automatically timed out.\n\nIf this value is set to NULL, then the session will be good indefinitely. However, by default, all APEX sessions older than 8 hours are purged every 24 hours. Thus, unless the frequency of this job is changed, the longest APEX session possible is closer to 8 hours.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session Management** area, locate **Maximum Session Length in Seconds** attribute and change its value to between 0 and 28800.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Max Rows to Query - Classic Report",
    "ruleKey": "MAX_ROWS_TO_QUERY_CLASSIC_REPORT",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-classic-reports.html#GUID-6C9E3F69-691B-4501-8020-097C92508561",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "MAXIMUM_ROWS_TO_QUERY",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "LESS_THAN",
    "valChar": null,
    "valNumber": 1000,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and source_type_code = 'SQL_QUERY'",
    "customQuery": null,
    "info": "The **Max Rows to Query** is the Classic Report **Number of Rows** attribute that represents a number of rows to display per **report page**. It is the pagination page size. \n\nFor performance reasons keep the **Max Rows to Query** value below 1000.",
    "fix": "To set the **Max Rows to Query** in a Classic Report:\n\n1.  Edit the corresponding page of your application and navigate to the Classic Report in question.\n2.  Select the Attributes node of the report.\n3.  In the Layout region, set **Number of Rows** to the value less than 1000.\n4.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Media List SQLi",
    "ruleKey": "MEDIA_LIST_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'TMPL_THEME_42$MEDIA_LIST'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Media List WHERE Clause SQLi",
    "ruleKey": "MEDIA_LIST_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$MEDIA_LIST'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "On Demand Application Process with No AuthZ",
    "ruleKey": "ON_DEMAND_APPLICATION_PROCESS_WITH_NO_AUTHZ",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "APP_PROCESS",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PROCESSES",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": "APPLICATION_PROCESS_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "PROCESS_NAME",
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and process_point = 'On Load: Before Header (page template header)'",
    "customQuery": null,
    "info": "Like most components in APEX, an On demand Application Process can have an **Authorization Scheme**.  By associating the **Authorization Scheme** with the On demand Application Process, only those users who are members of the corresponding **Authorization Scheme** will be able to run the process.\n\nThis technique is critical when using a central **Authentication Scheme**, such as LDAP. Without an application-level **Authorization Scheme**, any user in the LDAP directory will be able to run the process. Thus, it's a best practice to create a group - either in LDAP or via database tables - and add authorized users to that group. The application **Authorization Scheme** can then check to see if a user is a member of the associated group or not, thus either allowing them or preventing them from running the process.",
    "fix": "To associate an **Authorization Scheme** with an On Demand Application Process:\n\n1.  Edit your On Demand Application Process in **Shared Components**.\n2.  In the Authorization region, set the value of Authorization Scheme to any appropriate value except for **No Authorization Required**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "On Demand Page Process with No AuthZ",
    "ruleKey": "ON_DEMAND_PAGE_PROCESS_WITH_NO_AUTHZ",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "PAGE_PROCESS",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_PROC",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": "PROCESS_ID",
    "componentName": "PROCESS_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and process_point_code = 'ON_DEMAND'",
    "customQuery": null,
    "info": "Like most components in APEX, an On demand Page Process can have an **Authorization Scheme**.  By associating the **Authorization Scheme** with the On demand Page Process, only those users who are members of the corresponding **Authorization Scheme** will be able to execute the process.",
    "fix": "To associate an **Authorization Scheme** with an On Demand Page Process:\n\n1.  Edit the page and locate the **On Demand Page Process** in question. \n2.  Click on the process name in the _Page Rendering_ tree.\n3.  In the **Security** Region, set the **Authorization Scheme** attribute to any appropriate non NULL value.\n4.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Access Protection",
    "ruleKey": "PAGE_ACCESS_PROTECTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/preventing-url-tampering.html#GUID-C47B5B4C-FA49-47C7-BAAE-6D5A06DE029C",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "PAGE_ACCESS_PROTECTION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Arguments Must Have Checksum:No URL Access:No Arguments Allowed",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "Each page in an APEX application has an attribute called **Page Access Protection**. This attribute determines how a page can be accessed, and whether or not you can pass item values to the page.\n\nThere are four modes for **Page Access Protection**:\n\n*   **Unrestricted**  \n    This page can be accessed via the URL and all URL parameters (request, session state, item values) are allowed\n*   **Arguments Must Have Checksum**\n*   URL parameters ( request, session state, item values)can only be passed to this page if a corresponding checksum is also present in the URL. Individual items must also be protected at either the session, user or application level.\n*   **No Arguments Supported**  \n    URL parameters (request, session state, item values) for this page are prohibited, but the page can still be accessed via entering its corresponding URL.\n*   **No URL Access**  \n    Not only are URL parameters (request, session state, item values) prohibited, but the only way to access this page is the result of an APEX branch.\n\nBy default, all APEX pages are created with this attribute set to Unrestricted. That means that users can pass values to any of the URL parameters on any APEX page unless you take time to change this attribute.\n\nIf you elect to use Arguments Must Have Checksum, then enabling this attribute is only part one of a two step process. You should take care to enable the corresponding attribute for each item that you wish to protect on this page.",
    "fix": "To modify the **Page Access Protection** attribute:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the _Page Rendering_ tree.\n2.  In the Security Region, set the **Page Access Protection** attribute to anything except **Unrestricted**.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Authorization Scheme",
    "ruleKey": "PAGE_AUTHORIZATION_SCHEME",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A01-2021",
    "riskName": "Broken Access Control",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/providing-security-through-authorization.html#GUID-8FBF5F46-0541-4859-8470-D10E333DD271",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "AUTHORIZATION_SCHEME",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NOT_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0 \nand page_template <> 'Login'",
    "customQuery": null,
    "info": "Setting an **Authorization Scheme** at the page level is just as critical as setting one at the application level. Page-level authorization schemes restrict which authenticated users can see which pages. Quite often, applications will contain more than one role, and need to be secured so that users from one role can not see pages associated with other roles. Thus, each page should be associated with an **Authorization Scheme**, thus securing the page and all of its associated content.\n\nOften, developers will only associate the authorization scheme with a tab, link or button. This will only hide the corresponding table, link or button; it will do nothing to stop a malicious user from changing the URL to view potentially sensitive pages that they are not supposed to see.",
    "fix": "To associate an **Authorization Scheme** with a page:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, set the value of **Authorization Scheme** to the corresponding Authorization Scheme that you want to associate with this page.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Caching",
    "ruleKey": "PAGE_CACHING",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-page-attributes-in-page-designer.html#GUID-5CF0B715-7A6B-4A49-B14B-471CCA2C775C",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "CACHED",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "No",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "**Page Caching**  \nSelect how the Oracle APEX engine can **cache** HTML text on the server side. If caching can be used, it emits the cached result instead of computing it again. This cuts down on expensive computation time on the server. This feature is unrelated to the browser's caching capabilities.\n\nAvailable options include:  \nDisabled - Content is not cached and computed for each request.  \nEnabled - Content is cached and utilized by all users.  \nCache By User - Content is cached specifically for each user.  \nCache By Session - Content is cached specifically for each session.\n\nFrom a security standpoint, **Page Caching** should be **Disabled** so that page specific sensitive information will not be kept at the browser level. It will also ensure that information displayed is up to date.",
    "fix": "To modify the **Page Caching** attribute:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the _Page Rendering_ tree.\n2.  In the **Server Cache** Region, set the **Caching** attribute to **Disabled**.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Computation SQLi",
    "ruleKey": "PAGE_COMPUTATION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_COMPUTATION",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": null,
    "customQuery": "select\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id page_id \n  ,c.computation_id as component_id \n  ,null as component_name\n  ,null as column_name \n  ,c.item_name || ' / ' || c.computation_type as item_name\n  ,null as shared_comp_name\n  ,c.computation as current_value\n  ,'Criteria ' as valid_values\n  ,eval_pkg.eval_criteria(p_column_to_evaluate => COMPUTATION, p_rule_criteria_type_key => 'SQLI', p_application_id => #APP_ID#) as result \nfrom\n   apex_application_page_comp c\n  ,apex_application_page_items i\n ,apex_application_page_regions r \nwhere 1=1 \n  and c.application_id = #APP_ID# \n  and c.computation_type in ('SQL Query (return single value)','SQL Query (return colon separated value)','Expression','Function Body')\n  and c.item_name = i.item_name\n  and c.application_id = i.application_id\n  and i.region_id = r.region_id(+)",
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Computation** in the Page Rendering tree, and edit its **PL/SQL Function Body** in the **Computation** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Item Encryption",
    "ruleKey": "PAGE_ITEM_ENCRYPTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A02-2021",
    "riskName": "Cryptographic Failures",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-page-items.html#GUID-C89752E5-6CAD-49DF-9ED7-6DDAFC491F95",
    "builderUrlKey": "PAGE_ITEM",
    "impact": "ITEM",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_ITEMS",
    "columnToEvaluate": "ENCRYPT_SESSION_STATE",
    "componentId": "ITEM_ID",
    "componentName": null,
    "columnName": null,
    "itemName": "ITEM_NAME",
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "When users fill out a form in APEX, the data that is sent back to the server is stored unencrypted in the APEX session table - WWV\\_FLOW\\_DATA. While there are adequate precautions taken to ensure that other users can not see this data, there is nothing to stop an APEX workspace administrator or DBA from seeing it.\n\nThus, you should consider applying **Item Level Encryption** to any item that could contain sensitive data. With this feature enabled, the values of items in APEX session state are encrypted before they are stored, preventing APEX workspace administrator and even DBAs from snooping. \n\nEnabling this feature requires no additional changes to your APEX applications. You can still refer to encrypted items the same way you would refer to unencrypted ones. APEX will automatically encrypt and decrypt them for you.\n\nNote: Application Items do not currently support this feature. Thus, if you need to store data in an encrypted fashion, you should use Page 0 items instead.",
    "fix": "To enable **item-level encryption**:\n\n1.  Edit a page item in your application that you wish to enable item-level encryption.\n2.  In the Security region, set the value of **Store value encrypted in session state** to **Yes**.\n3.  Click **Apply Changes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Process SQLi",
    "ruleKey": "PAGE_PROCESS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "PAGE_PROCESS",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_PROC",
    "columnToEvaluate": "PROCESS_SOURCE",
    "componentId": "PROCESS_ID",
    "componentName": "PROCESS_NAME:PROCESS_POINT",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and process_type_code = 'PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Page Process** in the Page Rendering tree, and edit its **PL/SQL Code** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Page Requires Authentication",
    "ruleKey": "PAGE_REQUIRES_AUTHENTICATION",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/establishing-user-identity-through-authentication.html#GUID-45C4B1CD-4231-4FE9-8B5B-C90611F5F57B",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "PAGE_REQUIRES_AUTHENTICATION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "The **Authentication** page attribute determines whether a user needs to be authenticated or not in order to see the page. No specific membership or Authorization Scheme is required.\n\nIf you need some pages to be public - in that anyone will be able to view them - you can set this attribute to Page is Public. Otherwise, all pages in your application should have this set to Page Requires Authentication.",
    "fix": "To change the Authentication page-level attribute:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, set the value of Authentication to **Page Requires Authentication**.\n3.  Click **Save**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Process Button AuthZ Inconsistency",
    "ruleKey": "PROCESS_BUTTON_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\r\n(\r\nselect\r\n   application_id\r\n  ,button_name\r\n  ,button_id\r\n  ,authorization_scheme\r\n  ,authorization_scheme_id\r\nfrom\r\n   apex_application_page_buttons\r\nwhere 1=1\r\n  and authorization_scheme_id is not null\r\n  and application_id = #APP_ID#\r\n)\r\nselect\r\n   #EVAL_ID# as eval_id\r\n  ,#RULE_ID# as rule_id \r\n  ,c.application_id as application_id\r\n  ,page_id as page_id \r\n  ,p.process_id component_id \r\n  ,c.button_name || ' => ' || p.process_name as component_name\r\n  ,null as column_name \r\n  ,null as item_name\r\n  ,null as shared_comp_name\r\n  ,'Button: ' || nvl(c.authorization_scheme,'None') || ' / Process: ' || nvl(p.authorization_scheme,'None') as current_value\r\n  ,'AuthZ Schemes Match' as valid_values\r\n  ,case when nvl(p.authorization_scheme_id,0) = nvl(c.authorization_scheme_id,0) then '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' end as result\r\nfrom\r\n   apex_application_page_proc p\r\n  ,c\r\nwhere 1=1\r\n  and p.application_id = #APP_ID#\r\n  and p.when_button_pressed_id = c.button_id",
    "info": "The execution of a **Page Processes** can be linked to the click of a specific **Button** on the same page. When the **Authorization Schemes** of the Process and the Button do not match it might be possible for the user to have access to the Button and not the Process or vice versa.\r\n\r\n**APEX-SERT** flags **Page Processes** where the execution is tied to a Button, but where the Button's Authorization scheme doesn't match the Authorization Scheme for the Process.",
    "fix": "Check the Authorization Schemes on both the driving Button and the Page Process for compatibility. \r\n\r\nAlthough they are not _required_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provide the desired result.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Referrer Policy",
    "ruleKey": "REFERRER_POLICY",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-5AEB6EEF-A89B-41B6-B8D5-00A0FD926E8F",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "REFERRER_POLICY",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "strict-origin",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This attribute defines what Oracle APEX sends in the **Referrer-Policy** HTTP response header. Referrer-Policy controls what the browser sends to servers in the **Referer** and **Origin** request headers, when users click on links or submit pages. \n\nNormally, this information includes the full URL, including Oracle APEX session IDs, which should not be exposed to third parties. New applications should use the value **strict-origin**, unless there are specific business requirements for a different setting.\n\nPlease see the [documentation for the Referrer-Policy header and its available values](https://www.w3.org/TR/referrer-policy/) for further information.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Browser Security** area, locate **Referrer Policy** attribute and change its value to **strict-origin**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Reflow Report SQLi",
    "ruleKey": "REFLOW_REPORT_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code = 'NATIVE_JQM_REFLOW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Reflow Report WHERE Clause SQLi",
    "ruleKey": "REFLOW_REPORT_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'NATIVE_JQM_REFLOW'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Rejoin Sessions",
    "ruleKey": "REJOIN_SESSIONS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A01-2021",
    "riskName": "Broken Access Control",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/editing-page-attributes-in-page-designer.html#GUID-C5DC542A-6963-43AB-AA35-26FDC0730B18",
    "builderUrlKey": "PAGE",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGES",
    "columnToEvaluate": "REJOIN_EXISTING_SESSIONS",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Disabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": "and page_id > 0",
    "customQuery": null,
    "info": "The **Rejoin Sessions** attribute will allow users to rejoin a previously established session without providing a Session ID. APEX will only use the existing cookie to determine whether or not to consider the current session as valid.\n\nEnabling this option does present a security risk, albeint a minimum one.  A hacker would still need to be able to gain access to and replicate an APEX session cookie to hijack a session. Ideally, if not needed, this option should be set to **Disabled**.",
    "fix": "To alter the value of **Rejoin Sessions** for a specific page:\n\n1.  Edit the page attributes for the page in question by clicking on it's name in the Page Rendering tree.\n2.  In the Security region, set the value for Rejoin Sessions to **Disabled**. Alternatively, if the Application Level setting is set to **Disabled**, then set it to **Application Default**.\n3.  Click **Save**.Rejoin Sessions has four possible settings at the page level:\n    1.  **Application Default** - This will take its value from the current application's Rejoin Sessions attribute.\n    2.  **Disabled** - Sessions cannot be rejoined at all\n    3.  **Enabled for Public Sessions** - APEX will attempt to rejoin an existing session only when navigating to a page that is publicly accessible.",
    "timeToFix": null,
    "ruleSeverityName": "Low",
    "ruleSeverityKey": "LOW",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Runtime API Usage",
    "ruleKey": "RUNTIME_API_USAGE",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A04-2021",
    "riskName": "Insecure Design",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-F2324900-0AD3-4C0A-8B86-AE4B9C25F991",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "RUNTIME_API_USAGE",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "IS_NULL",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This attribute controls how this application can access Oracle APEX APIs that modify applications and workspace data, while it is running.\n\n*   Modify This Application: The application can modify itself.\n*   Modify Other Applications: The application can change other applications in the workspace.\n*   Modify Workspace Repository: The application can change workspace users and groups.\n\nUnless there is a specific requirement, It is recommended to have all three options set to **No**.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Advanced** area, locate **Runtime API Usage** attribute and change all 3 options to **No**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Run Authorization on Background Jobs",
    "ruleKey": "RUN_AUTHORIZATION_ON_BACKGROUND_JOBS",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-69485470-823B-4CC0-9E11-1CF144054F53",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "AUTHORIZE_BATCH_JOB",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "This attribute defines whether the authorization schemes at application, page, region and column level are checked in the background job such as interactive report subscriptions. Options include:\n\n*   **On** - If you select **On**, the authorization is checked.\n*   **Off** - If you select **Off**, the authorization is ignored.\n\nNote: The background job authorization check uses cloned session state instead of the current session state. The cloned session state does NOT include collection, report settings nor session state set during the post authentication process. The authorization check may fail if session state in cloned session is not found.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Authorization** area, locate **Run on Background Job** attribute and change its value to **Yes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Run Authorization on Public Pages",
    "ruleKey": "RUN_AUTHORIZATION_ON_PUBLIC_PAGES",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-69485470-823B-4CC0-9E11-1CF144054F53",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "AUTHORIZE_PUBLIC_PAGES",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Yes",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "If a page is set to a Public Page, it is likely that the developer intended that page to always be available to anyone - regardless whether they are authenticated or not. However, if there is an Authorization Scheme associated with the application itself, it is possible that pages that intended to be public will not render, based on the result of the Authorization Scheme.\n\nIf this is the case, set **Run Authorization on Public Pages** to **No** so that pages that are set to public will bypass the application-level Authorization Scheme when rendering. If the Authorization Scheme still needs to be checked - even on public pages - then set set **Run Authorization on Public Pages** to **Yes**. Thus, the correct value of this attribute is largely dependent on the intended behavior of public pages, and is largely subjective.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Authorization** area, locate **Run on Public Pages** attribute and change its value to **Yes**.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Session State Protection",
    "ruleKey": "SESSION_STATE_PROTECTION",
    "categoryName": "Misconfiguration",
    "categoryKey": "MISCONFIGURATION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/configuring-security-attributes.html#GUID-D3ECB171-681E-4452-BB33-5E74EC0EE13E",
    "builderUrlKey": "APPLICATION_SECURITY_ATTRIBUTES",
    "impact": "APP",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATIONS",
    "columnToEvaluate": "SESSION_STATE_PROTECTION",
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "EQUALS",
    "valChar": "Enabled",
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": null,
    "info": "The **Session State Protection** attribute determines whether or not your application will provide support for the Session State Protection feature. Enabling it does not actually provide any protection. Each page and individual item must be configured for Session State Protection to work.\n\nIt is essential that **Session State Protection** be enabled and then configured in your application to prevent multiple types of attack.",
    "fix": "Navigate to your Application Definition, and select **Security tab**.\n\nIn **Session State Protection** area, locate **Session State Protection** attribute and set its value to **Enabled**.",
    "timeToFix": null,
    "ruleSeverityName": "High",
    "ruleSeverityKey": "HIGH",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Actions SQLi",
    "ruleKey": "TASK_DEFINITION_ACTIONS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEF_ACTIONS",
    "columnToEvaluate": "ACTION_CLOB",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "TASK_DEF_NAME:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and action_clob_language = 'PLSQL' and action_type_code = 'NATIVE_PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, select corresponding **Action**, and edit its **Code** in the **Code** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Actions SQL Query SQLi",
    "ruleKey": "TASK_DEFINITION_ACTIONS_SQL_QUERY_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEFS",
    "columnToEvaluate": "ACTIONS_SQL_QUERY",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and actions_sql_query is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, and edit its **Actions SQL Query** code in the **Settings** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Due On SQLi",
    "ruleKey": "TASK_DEFINITION_DUE_ON_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEFS",
    "columnToEvaluate": "DUE_ON_INTERVAL",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and due_on_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, and edit its **Due On** code in the **Deadline** region.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Parameter Value SQLi",
    "ruleKey": "TASK_DEFINITION_PARAMETER_VALUE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "TASK_DEFINITION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEF_COMP_PARAMS",
    "columnToEvaluate": "VALUE",
    "componentId": "COMPONENT_PARAMETER_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "COMPONENT_NAME:PARAM_NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Task Definition Participants SQLi",
    "ruleKey": "TASK_DEFINITION_PARTICIPANTS_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_TASKDEF_PARTICIPANTS",
    "columnToEvaluate": "VALUE",
    "componentId": "TASK_DEF_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "TASK_DEF_ID:TASK_DEF_NAME:PARTICIPANT_TYPE:VALUE_TYPE",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Task** definition in question, select corresponding **Participant** in the Participants region, and edit its **Value**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Theme Component Action AuthZ Inconsistency",
    "ruleKey": "THEME_COMPONENT_ACTION_AUTHZ_INCONSISTENCY",
    "categoryName": "Access Control",
    "categoryKey": "ACCESS_CONTROL",
    "riskCode": "A05-2021",
    "riskName": "Security Misconfiguration",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/attaching-an-authorization-scheme.html#GUID-84B6EB45-768F-4BA7-A20A-6A7EA3513A50",
    "builderUrlKey": "REGION",
    "impact": "COMPONENT",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "CUSTOM_QUERY",
    "viewName": null,
    "columnToEvaluate": null,
    "componentId": null,
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": null,
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": null,
    "additionalWhere": null,
    "customQuery": "with c as\n(\nselect\n   ic.application_id\n  ,ic.page_id\n  ,REGEXP_SUBSTR(ic.link_target, '[^:]+', 1, 2) as target_page_id\n  ,ic.region_name\n  ,ic.region_id\n  ,nvl(label, position_name) || ' (' || ic.display_sequence || ')' as column_alias\n  ,coalesce( ic.authorization_scheme, r.authorization_scheme) as authorization_scheme\n  ,coalesce( ic.authorization_scheme_id, r.authorization_scheme_id) as authorization_scheme_id\n  ,(select authorization_scheme\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme\n  ,(select authorization_scheme_id\n    from apex_application_pages \n    where to_char(page_id) = REGEXP_SUBSTR(link_target, '[^:]+', 1, 2) \n    and REGEXP_LIKE(REGEXP_SUBSTR(link_target, '[^:]+', 1, 2), '^[[:digit:]]+$') \n    and application_id = #APP_ID#\n  ) target_authorization_scheme_id\nfrom\n   apex_appl_page_comp_actions ic\n  ,apex_application_page_regions r\nwhere 1=1\n  and ic.region_id = r.region_id \n  and ic.link_target is not null\n  and ic.application_id = #APP_ID#\n)\nselect\n   #EVAL_ID# as eval_id\n  ,#RULE_ID# as rule_id \n  ,c.application_id as application_id\n  ,c.page_id as page_id \n  ,c.region_id component_id \n  ,c.column_alias as component_name\n  ,null as column_name \n  ,null as item_name\n  ,null as shared_comp_name\n  ,'Action: ' || nvl(authorization_scheme, 'None') || ' / Page: ' || nvl(target_authorization_scheme, 'None') as current_value\n  ,'AuthZ Schemes Match' as valid_values\n  ,case \n    when NOT regexp_like(target_page_id, '^[[:digit:]]+$') then \n      '{ \"reasons\":[ {\"reason\":\"target page is not a literal\"} ] ,\"result\":\"FAIL\" }'\n    when nvl(target_authorization_scheme_id,0) = nvl(authorization_scheme_id,0) then \n      '{ \"reasons\":[ ] ,\"result\":\"PASS\" }' else '{ \"reasons\":[ ] ,\"result\":\"FAIL\" }' \n   end as result\nfrom c\nwhere 1=1\n  and c.application_id = #APP_ID#",
    "info": "**APEX-SERT** flags **components** where the Authorization Scheme doesn't match the Authorization Scheme for the **Page**. This may provide users access to the Page but not the List Entries, or vice versa",
    "fix": "Check the **Authorization Schemes** on both the **component** and the **Page** for compatibility. Although they are not _**required**_ to be the same, developers need to make sure that the Authorization Schemes are compatible and will provided the desired result.\n\nWhen an theme component action uses a column substitution for the Action, it cannot be confirmed by APEX-SERT and will require an exception",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Timeline SQLi",
    "ruleKey": "TIMELINE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "REGION_SOURCE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and region_source is not null\nand source_type_code in 'TMPL_THEME_42$TIMELINE'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Timeline WHERE Clause SQLi",
    "ruleKey": "TIMELINE_WHERE_CLAUSE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "REGION",
    "impact": "REGION",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_REGIONS",
    "columnToEvaluate": "WHERE_CLAUSE",
    "componentId": "REGION_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and where_clause is not null\nand source_type_code = 'TMPL_THEME_42$TIMELINE'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Validation SQLi",
    "ruleKey": "VALIDATION_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "VALIDATION",
    "impact": "PAGE",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPLICATION_PAGE_VAL",
    "columnToEvaluate": "VALIDATION_EXPRESSION1",
    "componentId": "VALIDATION_ID",
    "componentName": "VALIDATION_NAME",
    "columnName": null,
    "itemName": null,
    "sharedCompName": null,
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and validation_type_code in \n  (\n   'EXPRESSION'\n  ,'PLSQL_ERROR'\n  ,'FUNC_BODY_RETURNING_BOOLEAN'\n  ,'FUNC_BODY_RETURNING_ERR_TEXT'\n  )",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Page** definition in question, select corresponding **Validation** in the Page Rendering tree, and edit its **PL/SQL Code raising Error** in the **Validation** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activities Additional Data SQLi",
    "ruleKey": "WORKFLOW_ACTIVITIES_ADDITIONAL_DATA_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACTIVITIES",
    "columnToEvaluate": "QUERY_SOURCE",
    "componentId": "ACTIVITY_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and query_source is not null",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Activity** in the Workflow Rendering tree **Activities** List, and edit its **SQL Query** code in the **Additional Data** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activity Source SQLi",
    "ruleKey": "WORKFLOW_ACTIVITIY_SOURCE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACTIVITIES",
    "columnToEvaluate": "ACTIVITY_CODE",
    "componentId": "ACTIVITY_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and activity_type_code = 'NATIVE_PLSQL' and activity_code_language = 'PLSQL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Activity** in the Workflow Rendering tree **Activities** List, and edit its **PL/SQL Code** in the **Source** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activity Email Attachment SQL SQLi",
    "ruleKey": "WORKFLOW_ACTIVITY_EMAIL_ATTACHMENT_SQL_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACTIVITIES",
    "columnToEvaluate": "ATTRIBUTE_09",
    "componentId": "ACTIVITY_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:NAME",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and activity_type_code = 'NATIVE_SEND_EMAIL'",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Activity** of type **Send E-Mail** in the Workflow Rendering tree **Activities** List, and edit its **Attachment SQL** in the **Settings** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Activity Variable SQLi",
    "ruleKey": "WORKFLOW_ACTIVITY_VARIABLE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_ACTIVITY_VARIABLE",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_ACT_VARS",
    "columnToEvaluate": "VALUE",
    "componentId": "VARIABLE_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:LABEL",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": "**DBMS\\_SQL**\n\nThe improper use of DBMS\\_SQL could introduce the potential for a SQL Injection attack - specifically if the SQL to be executed contains evaluated APEX items - even with the bind variable syntax.\n\n**EXECUTE IMMEDIATE**\n\nWhile not specifically a risk in itself, the use of EXECUTE IMMEDIATE is considered a risk as it can perform virtually any type of action within the parse as schema. Any use of EXECUTE IMMEDIATE should be treated with _extreme caution\\*\\*.\\*\\*_\n\n**&ITEM. syntax**\n\nUse of  &ITEM.  syntax can potentially leave an application open to SQL Injection attacks. Developers must take extreme care to insure that any use of this syntax is controlled in such a way that the SQL Injection risk is minimized.\n\nThis is especially true when &ITEM. Syntax is used as part of a SQL statement as the veriables will be replaced verbatim with the variable value. For example, suppose there is a form online that allows a user to sign on with a username and password which ultimately executes this query:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = '&USERNAME.' \nAND password = '&PASSWORD.'\n```\n\nIf the user were to enter this as their password:\n\n`i_dont_know' OR 'x' = 'x`\n\nThe resulting SQL would be:\n\n```sql\nSELECT COUNT(*) \nFROM users \nWHERE username = 'SCOTT' \nAND password = 'i_dont_know' OR 'x' = 'x'\n```\n\nThis will erroneously return 1 rather than No Data Found and allow the user to log in.    \nBy using bind variables, this can be avoided.\n\nAPEX-SERT will also ignore items that use the `&ITEM_NAME.` syntax if they are:\n\n*   Properly secured Application Items\n*   Properly secured Page Items\n*   Application Substitution Strings",
    "fix": "Navigate to the **Workflow** definition in question, select corresponding **Variable** in the Workflow Rendering tree **Activity Variables** List, and edit its **SQL Query** in the **Value** region. Click **Save**.\n\n**&ITEM. syntax**\n\nExamine the code for uses of &ITEM. syntax and, wherever possible, replace the usage with:\n\n*   `:ITEM_NAME` bind variable syntax\n    *   in SQL Statements\n    *   in anonymous PL/SQL blocks in APEX\n*   `v('ITEM_NAME')` syntax\n    *   in stored PL/SQL program units called from APEX\n*   `ITEM_NAME` syntax\n    *   in conditions\n*   `&ITEM_NAME.`\n    *   Templates, Regions, Tabs, Menus, Lists\n\nWhen use of the `&ITEM.` syntax is necessary, developers can mitigate much of the risk by using `HTF.ESCAPE_SC` to escape the referenced item.\n\n_**Caution**: Use of_ `_**&ITEM**_`_**.** syntax in certain circumstances may also provide the opportunity for a Cross Site Scripting risk. See the XSS Section of APEX-SERT for details._\n\n---\n\n**DBMS\\_SQL** \n\nVerify that any use of `DBMS_SQL` is not evaluating APEX items before executing them.\n\nWhen you are forced to use `&ITEM.` notation, always be aware of the source of those items and whether or not they have been properly escaped using the `HTF.ESCAPE_SC` function.\n\nBeware of the improper use of Bind Variables in Dynamic SQL. For Instance:\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno =' || :P1_EMPNO;\nRETURN l_sql;\n```\n\nis no better than using `&ITEM.` syntax, as the value of the bind variable will be concatenated verbatim to the query string. Instead, be sure to embed the bind variables in the string, so that when the query executes, they appear as bind variables, not evaluated values.\n\n```sql\nl_sql := 'SELECT * FROM emp\nWHERE empno = :P1_EMPNO';\nRETURN l_sql;\n```\n\n---\n\n**Execute Immediate**\n\nEither avoid use of `EXECUTE IMMEDIATE`, or do everything possible to endure that the code that is being executed can not be maliciously influenced by the input of end users. Developers should pay special attention to any use of `EXECUTE IMMEDIATE` that uses values from the APEX Session State as they may be able to be directly or indirectly influenced by end users.",
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Participants Value SQLi",
    "ruleKey": "WORKFLOW_PARTICIPANTS_VALUE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_PARTICIPANT",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_PARTICIPANT",
    "columnToEvaluate": "VALUE",
    "componentId": "PARTICIPANT_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:PARTICIPANT_TYPE",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value_type_code in ('SQL_QUERY','FUNCTION_BODY','EXPRESSION')",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Variables Value SQLi",
    "ruleKey": "WORKFLOW_VARIABLES_VALUE_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_VARIABLE",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_VARIABLES",
    "columnToEvaluate": "VALUE",
    "componentId": "VARIABLE_ID",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION:LABEL",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and value is not null",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  },
  {
    "ruleName": "Workflow Version Additional Data SQLi",
    "ruleKey": "WORKFLOW_VERSION_ADDITIONAL_DATA_SQLI",
    "categoryName": "SQL Injection",
    "categoryKey": "SQL_INJECTION",
    "riskCode": "A03-2021",
    "riskName": "Injection",
    "apexVersion": 24.2,
    "helpUrl": "htmdb/managing-application-security.html#GUID-417EAE67-7A36-4AE0-816B-D28716829F96",
    "builderUrlKey": "WORKFLOW_VERSION",
    "impact": "SC",
    "activeYN": "Y",
    "internalYN": "N",
    "ruleType": "APEX_VIEW",
    "viewName": "APEX_APPL_WORKFLOW_VERSIONS",
    "columnToEvaluate": "QUERY_SOURCE",
    "componentId": "WORKFLOW_VERSION",
    "componentName": null,
    "columnName": null,
    "itemName": null,
    "sharedCompName": "WORKFLOW_NAME:WORKFLOW_VERSION",
    "operand": "CRITERIA",
    "valChar": null,
    "valNumber": null,
    "caseSensitiveYN": "N",
    "ruleCriteriaTypeKey": "SQLI",
    "additionalWhere": "and query_type_code = 'SQL'",
    "customQuery": null,
    "info": null,
    "fix": null,
    "timeToFix": null,
    "ruleSeverityName": "Medium",
    "ruleSeverityKey": "MEDIUM",
    "descriotion": null,
    "createdBy": "ACDC",
    "createdOn": null,
    "updatedBy": "ACDC",
    "updatedOn": null
  }
]